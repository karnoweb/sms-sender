

# فاز ۷ — تست‌های نهایی و جامع

## ساختار فایل‌های جدید

```
tests/
├── TestCase.php                          ← بدون تغییر
├── Fakes/
│   ├── DeliveryReportDriver.php          ← انتقال از فاز ۵ + بهبود
│   ├── FailingDeliveryReportDriver.php   ← انتقال از فاز ۵
│   ├── FailingDriver.php                 ← انتقال از فاز ۴
│   ├── RecordingDriver.php               ← انتقال از فاز ۴ + بهبود
│   └── BuggyDriver.php                   ← انتقال از فاز ۴
├── Unit/
│   ├── Contracts/
│   │   ├── SmsDriverContractTest.php
│   │   ├── DeliveryReportFetcherContractTest.php
│   │   └── SmsUsageHandlerContractTest.php
│   ├── Enums/
│   │   ├── SmsSendStatusEnumTest.php
│   │   └── SmsTemplateEnumTest.php
│   ├── Exceptions/
│   │   └── ExceptionsTest.php
│   ├── Models/
│   │   └── SmsModelTest.php
│   ├── Support/
│   │   ├── NullUsageHandlerTest.php
│   │   └── DefaultUsageHandlerTest.php
│   └── SmsManager/
│       ├── BuilderTest.php
│       ├── TemplateCompilerTest.php
│       ├── DriverResolutionTest.php
│       └── ResetTest.php
├── Feature/
│   ├── ServiceProviderTest.php
│   ├── SendTest.php
│   ├── FailoverTest.php
│   ├── DeliveryReportTest.php
│   └── UsageHandlerTest.php
└── Integration/                           ← جدید
    ├── EndToEndTest.php                   ← جدید
    ├── CustomDriverTest.php               ← جدید
    ├── CustomModelTest.php                ← جدید
    └── ConcurrencyTest.php                ← جدید
phpunit.xml                                ← جدید
```

---

## ۱. `phpunit.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
    bootstrap="vendor/autoload.php"
    colors="true"
    failOnRisky="true"
    failOnWarning="true"
>
    <!--
    |======================================================================
    | Test Suites
    |======================================================================
    |
    | سه دسته تست:
    | - Unit:        تست‌های واحد بدون نیاز به دیتابیس (سریع)
    | - Feature:     تست‌های عملکردی با دیتابیس (متوسط)
    | - Integration: تست‌های سرتاسری شبیه‌سازی استفاده واقعی (کامل)
    |
    -->
    <testsuites>
        <testsuite name="Unit">
            <directory>tests/Unit</directory>
        </testsuite>
        <testsuite name="Feature">
            <directory>tests/Feature</directory>
        </testsuite>
        <testsuite name="Integration">
            <directory>tests/Integration</directory>
        </testsuite>
    </testsuites>

    <!--
    |======================================================================
    | Code Coverage
    |======================================================================
    |
    | فقط پوشه‌ی src/ بررسی می‌شود.
    | فایل‌های config و migration خارج از coverage هستند.
    |
    -->
    <source>
        <include>
            <directory>src</directory>
        </include>
    </source>

    <!--
    |======================================================================
    | PHP Settings
    |======================================================================
    |
    | - TESTBENCH_APP_BASE_PATH: مسیر اپلیکیشن تست Orchestra
    | - DB_CONNECTION: استفاده از SQLite in-memory برای سرعت
    | - SMS_DRIVER: درایور null برای تست
    |
    -->
    <php>
        <env name="DB_CONNECTION" value="testing"/>
        <env name="SMS_DRIVER" value="null"/>
        <env name="APP_KEY" value="base64:test1234567890abcdef1234567890ab"/>
    </php>
</phpunit>
```

---

## ۲. Fakes — جمع‌آوری و بهبود درایورهای تستی

### `tests/Fakes/RecordingDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\SmsDriver;

/**
 * درایور تستی که تمام ارسال‌ها را در آرایه‌ی استاتیک ذخیره می‌کند.
 *
 * کاربرد:
 * - بررسی اینکه آیا send() فراخوانی شده یا نه
 * - بررسی تعداد ارسال‌ها
 * - بررسی محتوای ارسال‌شده (شماره + پیام)
 *
 * نکته: از static استفاده شده تا بین instance های مختلف
 *        (که Container هر بار resolve می‌کند) داده‌ها مشترک باشند.
 */
class RecordingDriver implements SmsDriver
{
    /** @var array<int, array{phone: string, message: string}> */
    public static array $sent = [];

    /** @var array<string, mixed> credentials دریافتی (برای تست پاس شدن config) */
    public static array $receivedConfig = [];

    public function __construct(protected readonly array $config = [])
    {
        static::$receivedConfig = $config;
    }

    public static function reset(): void
    {
        static::$sent           = [];
        static::$receivedConfig = [];
    }

    public function send(string $phone, string $message): void
    {
        static::$sent[] = [
            'phone'   => $phone,
            'message' => $message,
        ];
    }

    /**
     * آیا پیامکی به شماره‌ی مشخصی ارسال شده؟
     */
    public static function hasSentTo(string $phone): bool
    {
        foreach (static::$sent as $item) {
            if ($item['phone'] === $phone) {
                return true;
            }
        }

        return false;
    }

    /**
     * آیا پیامکی با متن مشخصی ارسال شده؟
     */
    public static function hasSentMessage(string $message): bool
    {
        foreach (static::$sent as $item) {
            if ($item['message'] === $message) {
                return true;
            }
        }

        return false;
    }
}
```

### `tests/Fakes/FailingDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Exceptions\DriverConnectionException;

/**
 * درایور تستی که همیشه خطای ارتباطی می‌دهد.
 * شبیه‌سازی سرویس‌دهنده‌ی از دسترس خارج.
 */
class FailingDriver implements SmsDriver
{
    public function __construct(protected readonly array $config = []) {}

    public function send(string $phone, string $message): void
    {
        throw new DriverConnectionException('Simulated connection failure');
    }
}
```

### `tests/Fakes/BuggyDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\SmsDriver;

/**
 * درایور تستی که یک خطای غیرمنتظره (bug) پرتاب می‌کند.
 * برای تست اینکه باگ‌ها Failover را فعال نمی‌کنند.
 */
class BuggyDriver implements SmsDriver
{
    public function __construct(protected readonly array $config = []) {}

    public function send(string $phone, string $message): void
    {
        throw new \RuntimeException('Unexpected bug in driver');
    }
}
```

### `tests/Fakes/DeliveryReportDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;

/**
 * درایور تستی با پشتیبانی از Delivery Report.
 *
 * قابلیت‌ها:
 * - ذخیره‌ی ارسال‌ها با provider_message_id خودکار
 * - پاسخ Delivery Report قابل تنظیم
 */
class DeliveryReportDriver implements SmsDriver, DeliveryReportFetcher
{
    /** @var array<int, array{phone: string, message: string, provider_message_id: string}> */
    public static array $sent = [];

    /** @var array<string, array{status: string}> پاسخ‌های Delivery Report */
    public static array $deliveryReports = [];

    private static int $counter = 0;

    public function __construct(protected readonly array $config = []) {}

    public static function reset(): void
    {
        static::$sent            = [];
        static::$deliveryReports = [];
        static::$counter         = 0;
    }

    public function send(string $phone, string $message): void
    {
        $providerMessageId = 'msg_' . (++static::$counter);

        static::$sent[] = [
            'phone'               => $phone,
            'message'             => $message,
            'provider_message_id' => $providerMessageId,
        ];
    }

    public function fetchDeliveryReport(string $providerMessageId): array
    {
        if (isset(static::$deliveryReports[$providerMessageId])) {
            return static::$deliveryReports[$providerMessageId];
        }

        return ['status' => 'unknown'];
    }

    public static function lastProviderMessageId(): ?string
    {
        if (empty(static::$sent)) {
            return null;
        }

        return end(static::$sent)['provider_message_id'];
    }
}
```

### `tests/Fakes/FailingDeliveryReportDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Exceptions\DriverConnectionException;

/**
 * درایور تستی که در Delivery Report خطا می‌دهد.
 */
class FailingDeliveryReportDriver implements SmsDriver, DeliveryReportFetcher
{
    public function __construct(protected readonly array $config = []) {}

    public function send(string $phone, string $message): void
    {
        // ارسال موفق
    }

    public function fetchDeliveryReport(string $providerMessageId): array
    {
        throw new DriverConnectionException('Delivery report API is unavailable.');
    }
}
```

---

## ۳. `tests/Integration/EndToEndTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Integration;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Enums\SmsTemplateEnum;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\SmsManager;
use Karnoweb\SmsSender\Support\DefaultUsageHandler;
use Karnoweb\SmsSender\Tests\Fakes\DeliveryReportDriver;
use Karnoweb\SmsSender\Tests\Fakes\FailingDriver;
use Karnoweb\SmsSender\Tests\Fakes\RecordingDriver;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های سرتاسری (End-to-End).
 *
 * این تست‌ها کل چرخه‌ی حیات پیامک را شبیه‌سازی می‌کنند:
 * ارسال → ثبت لاگ → Failover → بررسی وضعیت تحویل → به‌روزرسانی
 *
 * هدف: اطمینان از اینکه تمام اجزا (Builder, Driver, Logger, Failover,
 *       UsageHandler, DeliveryReport) با هم به درستی کار می‌کنند.
 */
class EndToEndTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        RecordingDriver::reset();
        DeliveryReportDriver::reset();
    }

    private function rebuildManager(): void
    {
        $this->app->forgetInstance(SmsManager::class);
        Sms::clearResolvedInstances();
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۱: ارسال ساده → بررسی لاگ → بررسی وضعیت
    // ═══════════════════════════════════════════════════════

    /**
     * شبیه‌سازی کامل:
     * ۱. ارسال OTP
     * ۲. بررسی ثبت لاگ
     * ۳. آپدیت provider_message_id (شبیه‌سازی callback درایور)
     * ۴. بررسی وضعیت تحویل → delivered
     */
    public function test_full_lifecycle_send_and_check_delivery(): void
    {
        // ── تنظیم درایور ──
        config([
            'sms.default' => 'delivery',
            'sms.drivers.delivery' => [
                'class'       => DeliveryReportDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── مرحله ۱: ارسال OTP ──
        Sms::otp(SmsTemplateEnum::LOGIN_OTP)
            ->input('code', '9876')
            ->number('09120000000')
            ->send();

        // ── مرحله ۲: بررسی لاگ ──
        $this->assertDatabaseCount('sms_messages', 1);

        $record = SmsModel::first();

        $this->assertEquals('delivery', $record->driver);
        $this->assertEquals('LOGIN_OTP', $record->template);
        $this->assertEquals(['code' => '9876'], $record->inputs);
        $this->assertEquals('09120000000', $record->phone);
        $this->assertStringContainsString('9876', $record->message);
        $this->assertSame(SmsSendStatusEnum::SENT, $record->status);

        // ── مرحله ۳: شبیه‌سازی provider_message_id ──
        // در واقعیت درایور این مقدار را برمی‌گرداند
        $providerMsgId = DeliveryReportDriver::lastProviderMessageId();
        $record->update(['provider_message_id' => $providerMsgId]);

        // ── مرحله ۴: تنظیم پاسخ Delivery Report ──
        DeliveryReportDriver::$deliveryReports[$providerMsgId] = [
            'status' => 'delivered',
        ];

        // ── مرحله ۵: بررسی وضعیت ──
        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('delivered', $results[0]['new_status']);
        $this->assertEquals('sent', $results[0]['old_status']);

        // ── مرحله ۶: بررسی به‌روزرسانی دیتابیس ──
        $fresh = $record->fresh();
        $this->assertSame(SmsSendStatusEnum::DELIVERED, $fresh->status);
        $this->assertArrayHasKey('delivered_at', $fresh->metadata);
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۲: Failover → لاگ → Delivery Report
    // ═══════════════════════════════════════════════════════

    /**
     * شبیه‌سازی:
     * ۱. درایور اول شکست → FAILED
     * ۲. Failover به درایور دوم → SENT
     * ۳. بررسی وضعیت → delivered
     */
    public function test_failover_then_delivery_report(): void
    {
        config([
            'sms.default'  => 'failing',
            'sms.failover' => ['delivery'],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.delivery' => [
                'class'       => DeliveryReportDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── ارسال ──
        Sms::message('پیام مهم')
            ->number('09120000000')
            ->send();

        // ── بررسی: ۲ رکورد (FAILED + SENT) ──
        $this->assertDatabaseCount('sms_messages', 2);

        $failedRecord = SmsModel::where('driver', 'failing')->first();
        $sentRecord   = SmsModel::where('driver', 'delivery')->first();

        $this->assertSame(SmsSendStatusEnum::FAILED, $failedRecord->status);
        $this->assertSame(SmsSendStatusEnum::SENT, $sentRecord->status);

        // ── شبیه‌سازی provider_message_id ──
        $providerMsgId = DeliveryReportDriver::lastProviderMessageId();
        $sentRecord->update(['provider_message_id' => $providerMsgId]);

        DeliveryReportDriver::$deliveryReports[$providerMsgId] = [
            'status' => 'delivered',
        ];

        // ── بررسی وضعیت ──
        $results = Sms::number('09120000000')->checkStatus();

        // فقط رکورد SENT بررسی شده (FAILED هم checkable نیست اگر terminal باشد)
        // ولی FAILED terminal نیست (FAILED is terminal = true)
        // پس فقط رکورد SENT باقی مانده
        $sentResults = collect($results)->where('driver', 'delivery');
        $this->assertCount(1, $sentResults);
        $this->assertEquals('delivered', $sentResults->first()['new_status']);
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۳: ارسال به چند نفر + بررسی وضعیت جداگانه
    // ═══════════════════════════════════════════════════════

    public function test_multi_recipient_send_and_individual_status_check(): void
    {
        config([
            'sms.default' => 'delivery',
            'sms.drivers.delivery' => [
                'class'       => DeliveryReportDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── ارسال به ۳ شماره ──
        Sms::message('اطلاع‌رسانی عمومی')
            ->numbers(['09121111111', '09122222222', '09123333333'])
            ->send();

        $this->assertDatabaseCount('sms_messages', 3);

        // ── آپدیت provider_message_id ها ──
        $records = SmsModel::all();
        $msgIds  = [];

        foreach ($records as $i => $record) {
            $msgId = 'msg_multi_' . ($i + 1);
            $record->update(['provider_message_id' => $msgId]);
            $msgIds[$record->phone] = $msgId;
        }

        // ── تنظیم پاسخ‌ها: یکی delivered، یکی failed، یکی unknown ──
        DeliveryReportDriver::$deliveryReports[$msgIds['09121111111']] = ['status' => 'delivered'];
        DeliveryReportDriver::$deliveryReports[$msgIds['09122222222']] = ['status' => 'failed'];
        // 09123333333 → unknown (پیش‌فرض)

        // ── بررسی وضعیت فقط برای یک شماره ──
        $results = Sms::number('09121111111')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('delivered', $results[0]['new_status']);

        // ── بررسی وضعیت همه ──
        $allResults = Sms::numbers(['09121111111', '09122222222', '09123333333'])
            ->checkStatus();

        // شماره ۱ دیگر checkable نیست (DELIVERED شده در بررسی قبلی)
        // شماره ۲ و ۳ هنوز checkable هستند
        $this->assertCount(2, $allResults);

        $phone2 = collect($allResults)->firstWhere('phone', '09122222222');
        $phone3 = collect($allResults)->firstWhere('phone', '09123333333');

        $this->assertEquals('failed', $phone2['new_status']);
        $this->assertEquals('unknown', $phone3['new_status']);
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۴: UsageHandler + Failover + ارسال موفق
    // ═══════════════════════════════════════════════════════

    public function test_usage_limit_then_failover_then_send(): void
    {
        config([
            'sms.usage_handler' => DefaultUsageHandler::class,
            'sms.default'       => 'limited',
            'sms.failover'      => ['recording'],
            'sms.drivers.limited' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
                'usage'       => [
                    'daily_limit' => 2,
                ],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── ارسال ۲ پیامک با درایور limited (پر شدن ظرفیت) ──
        Sms::message('پیامک ۱')->number('09120000000')->send();
        Sms::message('پیامک ۲')->number('09120000000')->send();

        $this->assertEquals(2, SmsModel::where('driver', 'limited')->count());

        // ── ارسال سوم: باید به recording برود ──
        Sms::message('پیامک ۳ — از recording')->number('09120000000')->send();

        $this->assertDatabaseHas('sms_messages', [
            'driver'  => 'recording',
            'message' => 'پیامک ۳ — از recording',
            'status'  => SmsSendStatusEnum::SENT->value,
        ]);
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۵: ارسال‌های پشت سر هم — استقلال State
    // ═══════════════════════════════════════════════════════

    public function test_sequential_sends_are_completely_independent(): void
    {
        config([
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── ارسال ۱: OTP ──
        Sms::otp(SmsTemplateEnum::LOGIN_OTP)
            ->input('code', '1111')
            ->number('09121111111')
            ->send();

        // ── ارسال ۲: پیام ساده ──
        Sms::message('پیام ساده')
            ->number('09122222222')
            ->send();

        // ── ارسال ۳: OTP دیگر ──
        Sms::otp(SmsTemplateEnum::VERIFY_PHONE)
            ->input('code', '3333')
            ->numbers(['09123333333', '09124444444'])
            ->send();

        // ── بررسی ──
        $this->assertDatabaseCount('sms_messages', 4);

        // ارسال ۱: فقط به شماره ۱
        $this->assertDatabaseHas('sms_messages', [
            'phone'    => '09121111111',
            'template' => 'LOGIN_OTP',
        ]);

        // ارسال ۲: فقط به شماره ۲، بدون template
        $sms2 = SmsModel::where('phone', '09122222222')->first();
        $this->assertEquals('پیام ساده', $sms2->message);
        $this->assertNull($sms2->template);
        $this->assertNull($sms2->inputs);

        // ارسال ۳: به ۲ شماره
        $sms3 = SmsModel::where('phone', '09123333333')->first();
        $this->assertEquals('VERIFY_PHONE', $sms3->template);
        $this->assertStringContainsString('3333', $sms3->message);

        // شماره ارسال ۱ نباید پیام ارسال ۲ را گرفته باشد
        $this->assertEquals(1, SmsModel::where('phone', '09121111111')->count());
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۶: Facade vs Instance vs DI
    // ═══════════════════════════════════════════════════════

    public function test_facade_and_instance_and_di_all_work(): void
    {
        config([
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── روش ۱: Facade ──
        Sms::message('از Facade')->number('09121111111')->send();

        // ── روش ۲: Static Instance ──
        SmsManager::instance()
            ->message('از Instance')
            ->number('09122222222')
            ->send();

        // ── روش ۳: Dependency Injection ──
        $manager = $this->app->make(SmsManager::class);
        $manager->message('از DI')->number('09123333333')->send();

        $this->assertDatabaseCount('sms_messages', 3);

        // همه باید با درایور recording ارسال شده باشند
        $this->assertEquals(3, SmsModel::where('driver', 'recording')->count());
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۷: ارسال با inputs خالی و پر
    // ═══════════════════════════════════════════════════════

    public function test_template_with_empty_and_populated_inputs(): void
    {
        config([
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── بدون input: placeholder باقی می‌ماند ──
        Sms::otp(SmsTemplateEnum::LOGIN_OTP)
            ->number('09120000000')
            ->send();

        $record1 = SmsModel::first();
        $this->assertStringContainsString('{code}', $record1->message);
        $this->assertNull($record1->inputs);

        // ── با input: placeholder جایگزین می‌شود ──
        Sms::otp(SmsTemplateEnum::LOGIN_OTP)
            ->input('code', '5555')
            ->number('09130000000')
            ->send();

        $record2 = SmsModel::where('phone', '09130000000')->first();
        $this->assertStringNotContainsString('{code}', $record2->message);
        $this->assertStringContainsString('5555', $record2->message);
    }

    // ═══════════════════════════════════════════════════════
    //  سناریو ۸: Error Recovery — ادامه کار بعد از خطا
    // ═══════════════════════════════════════════════════════

    public function test_manager_works_after_previous_failure(): void
    {
        config([
            'sms.default' => 'failing',
            'sms.failover' => [],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // ── ارسال ۱: شکست ──
        try {
            Sms::message('شکست')->number('09120000000')->send();
        } catch (\Throwable) {
            // انتظار داریم
        }

        // ── تغییر config به درایور سالم ──
        config(['sms.default' => 'recording']);

        // ── ارسال ۲: موفقیت ──
        Sms::message('موفقیت')->number('09120000000')->send();

        $this->assertDatabaseHas('sms_messages', [
            'driver'  => 'recording',
            'message' => 'موفقیت',
            'status'  => SmsSendStatusEnum::SENT->value,
        ]);
    }
}
```

---

## ۴. `tests/Integration/CustomDriverTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Integration;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\SmsManager;
use Karnoweb\SmsSender\Tests\TestCase;

// ────────────────────────────────────────────────────────────
//  درایورهای سفارشی شبیه‌سازی‌شده
// ────────────────────────────────────────────────────────────

/**
 * شبیه‌سازی درایور واقعی (مثل کاوه‌نگار).
 *
 * ویژگی‌ها:
 * - بررسی وجود api_key در config
 * - ذخیره‌ی ارسال‌ها با provider_message_id
 * - پشتیبانی از Delivery Report
 */
class FakeKavenegarDriver implements SmsDriver, DeliveryReportFetcher
{
    /** @var array<int, array<string, string>> */
    public static array $sent = [];

    /** @var array<string, array{status: string}> */
    public static array $reports = [];

    private static int $counter = 0;

    public function __construct(protected readonly array $config = [])
    {
        // شبیه‌سازی بررسی credentials
        if (empty($this->config['api_key'])) {
            throw new \Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException(
                'Kavenegar requires api_key in credentials.',
            );
        }
    }

    public static function reset(): void
    {
        static::$sent    = [];
        static::$reports = [];
        static::$counter = 0;
    }

    public function send(string $phone, string $message): void
    {
        $msgId = 'kav_' . (++static::$counter);

        static::$sent[] = [
            'phone'               => $phone,
            'message'             => $message,
            'provider_message_id' => $msgId,
        ];
    }

    public function fetchDeliveryReport(string $providerMessageId): array
    {
        return static::$reports[$providerMessageId] ?? ['status' => 'unknown'];
    }

    public static function lastProviderMessageId(): ?string
    {
        return empty(static::$sent) ? null : end(static::$sent)['provider_message_id'];
    }
}

/**
 * درایور ساده بدون Delivery Report.
 */
class FakeSimpleDriver implements SmsDriver
{
    public static array $sent = [];

    public function __construct(protected readonly array $config = []) {}

    public static function reset(): void
    {
        static::$sent = [];
    }

    public function send(string $phone, string $message): void
    {
        static::$sent[] = ['phone' => $phone, 'message' => $message];
    }
}


// ────────────────────────────────────────────────────────────
//  تست‌ها
// ────────────────────────────────────────────────────────────

/**
 * تست‌های پیاده‌سازی درایور سفارشی.
 *
 * هدف: اطمینان از اینکه یک توسعه‌دهنده می‌تواند به سادگی
 *       درایور خودش را بسازد و با پکیج استفاده کند.
 */
class CustomDriverTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        FakeKavenegarDriver::reset();
        FakeSimpleDriver::reset();
    }

    private function rebuildManager(): void
    {
        $this->app->forgetInstance(SmsManager::class);
        Sms::clearResolvedInstances();
    }

    // ─── Custom Driver Registration ────────────────────────

    public function test_custom_driver_can_be_registered_via_config(): void
    {
        config([
            'sms.default' => 'kavenegar',
            'sms.drivers.kavenegar' => [
                'class'       => FakeKavenegarDriver::class,
                'credentials' => [
                    'api_key' => 'test_api_key_123',
                    'sender'  => '10008663',
                ],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست کاوه‌نگار')
            ->number('09120000000')
            ->send();

        // درایور باید ارسال کرده باشد
        $this->assertCount(1, FakeKavenegarDriver::$sent);
        $this->assertEquals('09120000000', FakeKavenegarDriver::$sent[0]['phone']);

        // لاگ باید ثبت شده باشد
        $this->assertDatabaseHas('sms_messages', [
            'driver'  => 'kavenegar',
            'status'  => SmsSendStatusEnum::SENT->value,
        ]);
    }

    // ─── Credentials Validation ────────────────────────────

    public function test_custom_driver_validates_credentials(): void
    {
        config([
            'sms.default' => 'kavenegar',
            'sms.failover' => ['simple'],
            'sms.drivers.kavenegar' => [
                'class'       => FakeKavenegarDriver::class,
                'credentials' => [
                    // بدون api_key → Exception در constructor
                ],
            ],
            'sms.drivers.simple' => [
                'class'       => FakeSimpleDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        // Failover باید به simple برود
        Sms::message('تست')->number('09120000000')->send();

        $this->assertCount(1, FakeSimpleDriver::$sent);
        $this->assertEmpty(FakeKavenegarDriver::$sent);
    }

    // ─── Delivery Report with Custom Driver ────────────────

    public function test_custom_driver_delivery_report(): void
    {
        config([
            'sms.default' => 'kavenegar',
            'sms.drivers.kavenegar' => [
                'class'       => FakeKavenegarDriver::class,
                'credentials' => ['api_key' => 'test_key'],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست Delivery')
            ->number('09120000000')
            ->send();

        // آپدیت provider_message_id
        $record    = SmsModel::first();
        $msgId     = FakeKavenegarDriver::lastProviderMessageId();
        $record->update(['provider_message_id' => $msgId]);

        // تنظیم پاسخ
        FakeKavenegarDriver::$reports[$msgId] = ['status' => 'delivered'];

        // بررسی
        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('delivered', $results[0]['new_status']);
    }

    // ─── Simple Driver without Delivery Report ─────────────

    public function test_driver_without_delivery_report_is_skipped(): void
    {
        config([
            'sms.default' => 'simple',
            'sms.drivers.simple' => [
                'class'       => FakeSimpleDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست ساده')->number('09120000000')->send();

        $record = SmsModel::first();
        $record->update(['provider_message_id' => 'some_id']);

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertTrue($results[0]['skipped']);
        $this->assertStringContainsString('does not support', $results[0]['reason']);
    }

    // ─── Multiple Custom Drivers ───────────────────────────

    public function test_failover_between_custom_drivers(): void
    {
        config([
            'sms.default'  => 'kavenegar',
            'sms.failover' => ['simple'],
            'sms.drivers.kavenegar' => [
                'class'       => FakeKavenegarDriver::class,
                'credentials' => [],
                // بدون api_key → constructor Exception → Failover
            ],
            'sms.drivers.simple' => [
                'class'       => FakeSimpleDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست Failover سفارشی')
            ->number('09120000000')
            ->send();

        $this->assertEmpty(FakeKavenegarDriver::$sent);
        $this->assertCount(1, FakeSimpleDriver::$sent);

        $this->assertDatabaseHas('sms_messages', [
            'driver' => 'simple',
            'status' => SmsSendStatusEnum::SENT->value,
        ]);
    }

    // ─── Config Credentials Passed Correctly ───────────────

    public function test_credentials_are_passed_to_driver_constructor(): void
    {
        $credentials = [
            'api_key' => 'my_secret_key',
            'sender'  => '30001234',
            'timeout' => 30,
        ];

        config([
            'sms.default' => 'kavenegar',
            'sms.drivers.kavenegar' => [
                'class'       => FakeKavenegarDriver::class,
                'credentials' => $credentials,
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست')->number('09120000000')->send();

        // درایور باید credentials صحیح دریافت کرده باشد
        // (بررسی غیرمستقیم: اگر api_key نبود، Exception می‌داد)
        $this->assertCount(1, FakeKavenegarDriver::$sent);
    }
}
```

---

## ۵. `tests/Integration/CustomModelTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Integration;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as DefaultSmsModel;
use Karnoweb\SmsSender\SmsManager;
use Karnoweb\SmsSender\Tests\Fakes\RecordingDriver;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * مدل سفارشی اپلیکیشن برای تست.
 *
 * اپلیکیشن می‌تواند مدل Sms پیش‌فرض را با مدل خودش جایگزین کند
 * (مثلاً برای اضافه کردن relation یا accessor خاص).
 *
 * نکته: مدل سفارشی باید:
 * ۱. از همان جدول استفاده کند
 * ۲. همان fillable و casts را داشته باشد (یا سازگار باشد)
 * ۳. متدهای markAsSent, markAsFailed, markAsDelivered را داشته باشد
 */
class CustomSmsModel extends DefaultSmsModel
{
    /**
     * فیلد سفارشی برای ردیابی.
     */
    public static bool $customMethodCalled = false;

    /**
     * Override: اضافه کردن منطق سفارشی هنگام ثبت
     */
    protected static function booted(): void
    {
        static::creating(function (self $model) {
            static::$customMethodCalled = true;
        });
    }

    public static function resetCustomFlag(): void
    {
        static::$customMethodCalled = false;
    }
}


/**
 * تست‌های استفاده از مدل سفارشی.
 *
 * هدف: اطمینان از اینکه کاربر می‌تواند مدل Sms را با مدل خودش
 *       جایگزین کند و SmsManager از آن استفاده کند.
 */
class CustomModelTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        RecordingDriver::reset();
        CustomSmsModel::resetCustomFlag();
    }

    private function rebuildManager(): void
    {
        $this->app->forgetInstance(SmsManager::class);
        Sms::clearResolvedInstances();
    }

    // ─── Custom Model via Config ───────────────────────────

    public function test_custom_model_is_used_when_configured(): void
    {
        config([
            'sms.model'   => CustomSmsModel::class,
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست مدل سفارشی')
            ->number('09120000000')
            ->send();

        // observer سفارشی باید اجرا شده باشد
        $this->assertTrue(CustomSmsModel::$customMethodCalled);

        // رکورد باید در دیتابیس باشد
        $this->assertDatabaseHas('sms_messages', [
            'message' => 'تست مدل سفارشی',
        ]);

        // رکورد باید از نوع CustomSmsModel باشد
        $record = CustomSmsModel::first();
        $this->assertInstanceOf(CustomSmsModel::class, $record);
    }

    // ─── Default Model Works Without Config ────────────────

    public function test_default_model_used_when_not_configured(): void
    {
        config([
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->rebuildManager();

        Sms::message('تست مدل پیش‌فرض')
            ->number('09120000000')
            ->send();

        $record = DefaultSmsModel::first();
        $this->assertInstanceOf(DefaultSmsModel::class, $record);
    }

    // ─── Custom Model Scopes Work ──────────────────────────

    public function test_custom_model_scopes_work_with_check_status(): void
    {
        config([
            'sms.model'   => CustomSmsModel::class,
            'sms.default' => 'null',
        ]);

        $this->rebuildManager();

        // ساخت رکورد مستقیم
        CustomSmsModel::create([
            'driver'              => 'null',
            'phone'               => '09120000000',
            'message'             => 'تست',
            'status'              => SmsSendStatusEnum::SENT,
            'provider_message_id' => null,
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        // رکورد بدون provider_message_id باید skip شود
        $this->assertCount(1, $results);
        $this->assertTrue($results[0]['skipped']);
    }
}
```

---

## ۶. `tests/Integration/ConcurrencyTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Integration;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\SmsManager;
use Karnoweb\SmsSender\Tests\Fakes\RecordingDriver;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های مربوط به استفاده‌ی همزمان و مجدد از SmsManager.
 *
 * هدف: اطمینان از اینکه Singleton SmsManager در شرایط مختلف
 *       به درستی state خود را مدیریت می‌کند.
 *
 * نکته: این تست‌ها concurrency واقعی (multi-thread) را تست نمی‌کنند
 *        بلکه sequential reuse و state isolation را بررسی می‌کنند.
 */
class ConcurrencyTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        RecordingDriver::reset();

        config([
            'sms.default' => 'recording',
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->app->forgetInstance(SmsManager::class);
        Sms::clearResolvedInstances();
    }

    // ─── Rapid Sequential Sends ────────────────────────────

    public function test_rapid_sequential_sends_are_independent(): void
    {
        $phones = [
            '09121111111',
            '09122222222',
            '09123333333',
            '09124444444',
            '09125555555',
        ];

        // ارسال سریع پشت سر هم
        foreach ($phones as $i => $phone) {
            Sms::message("پیام شماره {$i}")
                ->number($phone)
                ->send();
        }

        // هر شماره باید دقیقاً ۱ پیامک داشته باشد
        $this->assertDatabaseCount('sms_messages', 5);

        foreach ($phones as $i => $phone) {
            $this->assertDatabaseHas('sms_messages', [
                'phone'   => $phone,
                'message' => "پیام شماره {$i}",
            ]);

            // هر شماره فقط ۱ رکورد
            $this->assertEquals(1, SmsModel::where('phone', $phone)->count());
        }
    }

    // ─── Interleaved Build and Send ────────────────────────

    public function test_build_chain_is_not_affected_by_previous_failure(): void
    {
        // ارسال ۱: موفق
        Sms::message('اول')->number('09121111111')->send();

        // ارسال ۲: خطا (بدون گیرنده)
        try {
            Sms::message('دوم')->send();
        } catch (\Throwable) {
            // OK
        }

        // ارسال ۳: باید مستقل باشد
        Sms::message('سوم')->number('09123333333')->send();

        $this->assertDatabaseCount('sms_messages', 2);

        $this->assertDatabaseHas('sms_messages', [
            'phone'   => '09121111111',
            'message' => 'اول',
        ]);

        $this->assertDatabaseHas('sms_messages', [
            'phone'   => '09123333333',
            'message' => 'سوم',
        ]);
    }

    // ─── Mixed Operations: Send + CheckStatus ──────────────

    public function test_send_and_check_status_interleaved(): void
    {
        // ارسال ۱
        Sms::message('پیام ۱')->number('09121111111')->send();

        // بررسی وضعیت (شماره‌ای که رکورد ندارد → خالی)
        $results = Sms::number('09129999999')->checkStatus();
        $this->assertEmpty($results);

        // ارسال ۲ — state باید پاک باشد
        Sms::message('پیام ۲')->number('09122222222')->send();

        // بررسی وضعیت شماره‌ی ارسال ۱
        $results = Sms::number('09121111111')->checkStatus();
        $this->assertCount(1, $results);

        // ارسال ۳ — بعد از checkStatus
        Sms::message('پیام ۳')->number('09123333333')->send();

        $this->assertDatabaseCount('sms_messages', 3);
    }

    // ─── Singleton Stability ───────────────────────────────

    public function test_singleton_remains_usable_after_many_operations(): void
    {
        // ۲۰ عملیات پشت سر هم
        for ($i = 1; $i <= 20; $i++) {
            $phone = '0912' . str_pad((string) $i, 7, '0', STR_PAD_LEFT);

            Sms::message("پیام {$i}")
                ->number($phone)
                ->send();
        }

        $this->assertDatabaseCount('sms_messages', 20);

        // تمام رکوردها باید SENT باشند
        $this->assertEquals(
            20,
            SmsModel::where('status', SmsSendStatusEnum::SENT)->count(),
        );
    }

    // ─── Builder Not Leaking Between Calls ─────────────────

    public function test_otp_inputs_do_not_leak_to_next_call(): void
    {
        // ارسال OTP با input
        Sms::otp(\Karnoweb\SmsSender\Enums\SmsTemplateEnum::LOGIN_OTP)
            ->input('code', '1234')
            ->number('09121111111')
            ->send();

        // ارسال پیام ساده — نباید input قبلی باقی مانده باشد
        Sms::message('پیام ساده')
            ->number('09122222222')
            ->send();

        $simpleRecord = SmsModel::where('phone', '09122222222')->first();

        $this->assertEquals('پیام ساده', $simpleRecord->message);
        $this->assertNull($simpleRecord->template);
        $this->assertNull($simpleRecord->inputs);
    }

    public function test_numbers_do_not_leak_between_sends(): void
    {
        // ارسال به ۲ شماره
        Sms::message('پیام ۱')
            ->numbers(['09121111111', '09122222222'])
            ->send();

        // ارسال به ۱ شماره — نباید شماره‌های قبلی باقی بمانند
        Sms::message('پیام ۲')
            ->number('09123333333')
            ->send();

        // پیام ۲ فقط باید به شماره ۳ رفته باشد
        $this->assertEquals(
            1,
            SmsModel::where('message', 'پیام ۲')->count(),
        );

        $this->assertDatabaseHas('sms_messages', [
            'message' => 'پیام ۲',
            'phone'   => '09123333333',
        ]);

        $this->assertDatabaseMissing('sms_messages', [
            'message' => 'پیام ۲',
            'phone'   => '09121111111',
        ]);
    }

    // ─── Template Does Not Leak ────────────────────────────

    public function test_template_name_does_not_leak(): void
    {
        // ارسال OTP
        Sms::otp(\Karnoweb\SmsSender\Enums\SmsTemplateEnum::LOGIN_OTP)
            ->input('code', '9999')
            ->number('09121111111')
            ->send();

        // ارسال ساده
        Sms::message('بدون قالب')
            ->number('09122222222')
            ->send();

        $otpRecord    = SmsModel::where('phone', '09121111111')->first();
        $simpleRecord = SmsModel::where('phone', '09122222222')->first();

        $this->assertEquals('LOGIN_OTP', $otpRecord->template);
        $this->assertNull($simpleRecord->template);
    }

    // ─── CheckStatus Does Not Affect Next Send ─────────────

    public function test_check_status_does_not_pollute_next_send(): void
    {
        // ارسال اول
        Sms::message('قبل از check')->number('09121111111')->send();

        // بررسی وضعیت
        Sms::number('09121111111')->checkStatus();

        // ارسال دوم — شماره‌ی checkStatus نباید باقی باشد
        Sms::message('بعد از check')->number('09122222222')->send();

        // "بعد از check" فقط باید به شماره ۲ رفته باشد
        $this->assertDatabaseHas('sms_messages', [
            'message' => 'بعد از check',
            'phone'   => '09122222222',
        ]);

        $this->assertEquals(
            1,
            SmsModel::where('message', 'بعد از check')->count(),
        );
    }
}
```

---

## ۷. به‌روزرسانی تست‌های فاز ۴ — استفاده از Fakes مشترک

### `tests/Feature/FailoverTest.php` (به‌روزرسانی import ها)

```php
<?php

namespace Karnoweb\SmsSender\Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Exceptions\DriverConnectionException;
use Karnoweb\SmsSender\Exceptions\DriverNotAvailableException;
use Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\Tests\Fakes\BuggyDriver;
use Karnoweb\SmsSender\Tests\Fakes\FailingDriver;
use Karnoweb\SmsSender\Tests\Fakes\RecordingDriver;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های مکانیزم Failover.
 *
 * حالا از Fakes مشترک (tests/Fakes/) استفاده می‌شود
 * به جای تعریف inline در فایل تست.
 */
class FailoverTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        RecordingDriver::reset();
    }

    public function test_first_driver_success_no_failover(): void
    {
        config([
            'sms.default'  => 'recording',
            'sms.failover' => ['failing'],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
        ]);

        Sms::message('تست')->number('09120000000')->send();

        $this->assertCount(1, RecordingDriver::$sent);
        $this->assertDatabaseHas('sms_messages', [
            'driver' => 'recording',
            'status' => SmsSendStatusEnum::SENT->value,
        ]);
    }

    public function test_failover_to_second_driver_on_connection_error(): void
    {
        config([
            'sms.default'  => 'failing',
            'sms.failover' => ['recording'],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        Sms::message('تست failover')->number('09120000000')->send();

        $this->assertCount(1, RecordingDriver::$sent);

        $this->assertDatabaseHas('sms_messages', [
            'driver' => 'failing',
            'status' => SmsSendStatusEnum::FAILED->value,
        ]);

        $this->assertDatabaseHas('sms_messages', [
            'driver' => 'recording',
            'status' => SmsSendStatusEnum::SENT->value,
        ]);
    }

    public function test_all_drivers_fail_throws_not_available(): void
    {
        config([
            'sms.default'  => 'failing1',
            'sms.failover' => ['failing2'],
            'sms.drivers.failing1' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.failing2' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->expectException(DriverNotAvailableException::class);

        Sms::message('تست شکست')->number('09120000000')->send();
    }

    public function test_not_available_exception_chains_last_error(): void
    {
        config([
            'sms.default'  => 'failing',
            'sms.failover' => [],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
        ]);

        try {
            Sms::message('تست')->number('09120000000')->send();
            $this->fail('Expected DriverNotAvailableException');
        } catch (DriverNotAvailableException $e) {
            $this->assertInstanceOf(DriverConnectionException::class, $e->getPrevious());
        }
    }

    public function test_unexpected_exception_bubbles_up_without_failover(): void
    {
        config([
            'sms.default'  => 'buggy',
            'sms.failover' => ['recording'],
            'sms.drivers.buggy' => [
                'class'       => BuggyDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Unexpected bug');

        Sms::message('تست باگ')->number('09120000000')->send();
    }

    public function test_unexpected_exception_does_not_trigger_second_driver(): void
    {
        config([
            'sms.default'  => 'buggy',
            'sms.failover' => ['recording'],
            'sms.drivers.buggy' => [
                'class'       => BuggyDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        try {
            Sms::message('تست')->number('09120000000')->send();
        } catch (\RuntimeException) {
        }

        $this->assertEmpty(RecordingDriver::$sent);
    }

    public function test_invalid_config_triggers_failover(): void
    {
        config([
            'sms.default'  => 'broken',
            'sms.failover' => ['recording'],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        Sms::message('تست config خراب')->number('09120000000')->send();

        $this->assertCount(1, RecordingDriver::$sent);
    }

    public function test_failover_resends_all_numbers_with_new_driver(): void
    {
        config([
            'sms.default'  => 'failing',
            'sms.failover' => ['recording'],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
            'sms.drivers.recording' => [
                'class'       => RecordingDriver::class,
                'credentials' => [],
            ],
        ]);

        Sms::message('تست')
            ->numbers(['09120000000', '09130000000'])
            ->send();

        $this->assertCount(2, RecordingDriver::$sent);
    }

    public function test_state_resets_after_failover_exception(): void
    {
        config([
            'sms.default'  => 'failing',
            'sms.failover' => [],
            'sms.drivers.failing' => [
                'class'       => FailingDriver::class,
                'credentials' => [],
            ],
        ]);

        try {
            Sms::message('تست')->number('09120000000')->send();
        } catch (DriverNotAvailableException) {
        }

        $this->expectException(InvalidDriverConfigurationException::class);
        Sms::send();
    }
}
```

---

## ۸. خلاصه‌ی تمام تست‌ها

### نقشه‌ی تست‌ها

```
tests/
├── Unit/                                 (بدون دیتابیس — سریع)
│   ├── Contracts/
│   │   ├── SmsDriverContractTest          5 tests
│   │   ├── DeliveryReportFetcherContractTest  4 tests
│   │   └── SmsUsageHandlerContractTest    3 tests
│   ├── Enums/
│   │   ├── SmsSendStatusEnumTest          8 tests
│   │   └── SmsTemplateEnumTest            6 tests
│   ├── Exceptions/
│   │   └── ExceptionsTest                 8 tests
│   ├── Models/
│   │   └── SmsModelTest                  18 tests  (with DB)
│   ├── Support/
│   │   ├── NullUsageHandlerTest           2 tests
│   │   └── DefaultUsageHandlerTest       16 tests  (with DB)
│   └── SmsManager/
│       ├── BuilderTest                   14 tests
│       ├── TemplateCompilerTest          10 tests
│       ├── DriverResolutionTest          10 tests
│       ├── ResetTest                      3 tests
│       └── CheckStatusTest               4 tests
│
├── Feature/                              (با دیتابیس — متوسط)
│   ├── ServiceProviderTest                9 tests
│   ├── SendTest                          12 tests
│   ├── FailoverTest                       8 tests
│   ├── DeliveryReportTest                12 tests
│   └── UsageHandlerTest                  10 tests
│
└── Integration/                          (سرتاسری — کامل)
    ├── EndToEndTest                       8 tests
    ├── CustomDriverTest                   5 tests
    ├── CustomModelTest                    3 tests
    └── ConcurrencyTest                    8 tests
                                    ──────────────
                                    Total: ~176 tests
```

---

## ✅ چک‌لیست فاز ۷

| آیتم | وضعیت |
|---|---|
| `phpunit.xml` — سه test suite (Unit, Feature, Integration) | ✅ |
| Fakes متمرکز — جمع‌آوری درایورهای تستی در `tests/Fakes/` | ✅ |
| `RecordingDriver` — بهبود با helper methods | ✅ |
| `EndToEndTest` — ۸ سناریوی سرتاسری (lifecycle, failover, usage, state) | ✅ |
| `CustomDriverTest` — ۵ سناریو (registration, credentials, delivery report, failover) | ✅ |
| `CustomModelTest` — ۳ سناریو (custom model, default model, scopes) | ✅ |
| `ConcurrencyTest` — ۸ سناریو (sequential, interleaved, leaking, singleton stability) | ✅ |
| به‌روزرسانی `FailoverTest` — استفاده از Fakes مشترک | ✅ |
| پوشش state isolation بین send و checkStatus | ✅ |
| پوشش Facade vs Instance vs DI | ✅ |
| پوشش Error Recovery | ✅ |
| ~۱۷۶ تست در مجموع | ✅ |
| کامنت‌های فارسی جامع | ✅ |

---

**فاز ۷ کامل شد.** بریم فاز ۸ (داکیومنتیشن جامع)؟