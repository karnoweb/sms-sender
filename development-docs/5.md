

# فاز ۵ — Delivery Report (`checkStatus()`)

## ساختار فایل‌های جدید و تغییریافته

```
src/
├── SmsManager.php                     ← اضافه شدن checkStatus()
├── Drivers/
│   └── NullDriver.php                 ← بدون تغییر
tests/
├── Unit/
│   └── SmsManager/
│       └── CheckStatusTest.php        ← جدید
└── Feature/
    └── DeliveryReportTest.php         ← جدید
```

---

## ۱. `src/SmsManager.php` (اضافه شدن `checkStatus`)

> فقط بخش جدید نشان داده می‌شود. بقیه‌ی کد از فاز ۴ بدون تغییر باقی می‌ماند.

```php
<?php

namespace Karnoweb\SmsSender;

use Illuminate\Contracts\Container\Container;
use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Contracts\SmsUsageHandler;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Enums\SmsTemplateEnum;
use Karnoweb\SmsSender\Exceptions\DriverConnectionException;
use Karnoweb\SmsSender\Exceptions\DriverNotAvailableException;
use Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException;
use Karnoweb\SmsSender\Models\Sms;

/**
 * مدیر اصلی ارسال پیامک — Builder / Facade سطح بالا.
 *
 * مسئولیت‌ها:
 * ───────────
 * ۱. رابط Fluent برای ساخت پیامک (قالب، ورودی، گیرنده)
 * ۲. Resolve کردن درایورها از Config و Container
 * ۳. ارسال با Failover خودکار بین درایورها
 * ۴. ثبت لاگ هر پیامک در دیتابیس
 * ۵. بررسی وضعیت تحویل (Delivery Report)
 *
 * نمونه استفاده:
 * ```php
 * // ارسال پیام
 * Sms::message('سلام')->number('09120000000')->send();
 *
 * // بررسی وضعیت تحویل
 * $results = Sms::number('09120000000')->checkStatus();
 * ```
 */
class SmsManager
{
    // ─── Builder State ─────────────────────────────────────

    /** @var array<int, string> شماره‌های گیرنده */
    protected array $toNumbers = [];

    /** @var string|null متن ساده‌ی پیام */
    protected ?string $messageText = null;

    /** @var string|null متن قالب */
    protected ?string $templateText = null;

    /** @var string|null نام قالب برای لاگ */
    protected ?string $templateName = null;

    /** @var array<string, string> ورودی‌های قالب */
    protected array $inputs = [];

    /** @var SmsUsageHandler handler کنترل مصرف */
    protected SmsUsageHandler $usageHandler;

    public function __construct(
        protected readonly Container $container,
    ) {
        $this->usageHandler = $this->resolveUsageHandler();
    }

    public static function instance(): static
    {
        /** @var static $instance */
        $instance = app(static::class);

        return $instance;
    }

    // ═══════════════════════════════════════════════════════
    //  BUILDER — تنظیم پیام
    // ═══════════════════════════════════════════════════════

    public function message(string $message): static
    {
        $this->messageText = $message;

        return $this;
    }

    public function otp(SmsTemplateEnum $template): static
    {
        $this->templateText = $template->value;
        $this->templateName = $template->name;

        return $this;
    }

    // ═══════════════════════════════════════════════════════
    //  BUILDER — تنظیم Inputs
    // ═══════════════════════════════════════════════════════

    public function input(string $key, string $value): static
    {
        $this->inputs[$key] = $value;

        return $this;
    }

    public function inputs(array $inputs): static
    {
        $this->inputs = array_merge($this->inputs, $inputs);

        return $this;
    }

    // ═══════════════════════════════════════════════════════
    //  BUILDER — تنظیم گیرنده‌ها
    // ═══════════════════════════════════════════════════════

    public function number(string $phone): static
    {
        $this->toNumbers[] = $phone;

        return $this;
    }

    public function numbers(array $phones): static
    {
        foreach ($phones as $phone) {
            $this->toNumbers[] = (string) $phone;
        }

        return $this;
    }

    // ═══════════════════════════════════════════════════════
    //  SEND — ارسال پیامک
    // ═══════════════════════════════════════════════════════

    public function send(): void
    {
        try {
            $targets = $this->resolveTargets();

            if (empty($targets)) {
                throw new InvalidDriverConfigurationException(
                    'No recipients provided.',
                );
            }

            $message = $this->resolveMessage();

            if ($message === null) {
                throw new InvalidDriverConfigurationException(
                    'No message or template provided.',
                );
            }

            $this->sendToTargets($targets, $message);
        } finally {
            $this->reset();
        }
    }

    // ═══════════════════════════════════════════════════════
    //  CHECK STATUS — بررسی وضعیت تحویل
    // ═══════════════════════════════════════════════════════

    /**
     * بررسی وضعیت تحویل پیامک‌ها برای گیرنده‌های مشخص‌شده.
     *
     * این متد پیامک‌هایی که هنوز در وضعیت PENDING یا SENT هستند را
     * از دیتابیس پیدا می‌کند و از درایور مربوطه وضعیت تحویل را استعلام می‌گیرد.
     *
     * نحوه‌ی استفاده:
     * ```php
     * // بررسی وضعیت برای یک شماره
     * $results = Sms::number('09120000000')->checkStatus();
     *
     * // بررسی وضعیت برای چند شماره
     * $results = Sms::numbers(['09120000000', '09130000000'])->checkStatus();
     * ```
     *
     * ساختار خروجی:
     * ```php
     * [
     *     [
     *         'sms_id'              => 1,
     *         'phone'               => '09120000000',
     *         'driver'              => 'kavenegar',
     *         'provider_message_id' => 'msg_abc123',
     *         'old_status'          => 'sent',
     *         'new_status'          => 'delivered',
     *     ],
     *     [
     *         'sms_id'              => 2,
     *         'phone'               => '09130000000',
     *         'driver'              => 'kavenegar',
     *         'provider_message_id' => 'msg_def456',
     *         'old_status'          => 'sent',
     *         'new_status'          => 'failed',
     *     ],
     *     [
     *         'sms_id'              => 3,
     *         'phone'               => '09140000000',
     *         'driver'              => 'melipayamak',
     *         'provider_message_id' => null,
     *         'old_status'          => 'pending',
     *         'skipped'             => true,
     *         'reason'              => 'No provider_message_id available.',
     *     ],
     *     [
     *         'sms_id'              => 4,
     *         'phone'               => '09150000000',
     *         'driver'              => 'local',
     *         'provider_message_id' => 'msg_xyz',
     *         'old_status'          => 'sent',
     *         'skipped'             => true,
     *         'reason'              => 'Driver does not support delivery reports.',
     *     ],
     *     [
     *         'sms_id'              => 5,
     *         'phone'               => '09160000000',
     *         'driver'              => 'kavenegar',
     *         'provider_message_id' => 'msg_err',
     *         'old_status'          => 'sent',
     *         'error'               => 'Connection timeout',
     *     ],
     * ]
     * ```
     *
     * نکات مهم:
     * ──────────
     * - فقط رکوردهای PENDING و SENT بررسی می‌شوند (وضعیت‌های غیرنهایی)
     * - اگر رکورد provider_message_id نداشته باشد، skip می‌شود
     * - اگر درایور DeliveryReportFetcher نباشد، skip می‌شود
     * - خطاها catch می‌شوند و در خروجی با کلید 'error' برگردانده می‌شوند
     * - اگر وضعیت جدید با وضعیت قبلی فرق کند، رکورد در دیتابیس به‌روزرسانی می‌شود
     * - بعد از اتمام، state ریست می‌شود
     *
     * @return array<int, array<string, mixed>> آرایه‌ی نتایج بررسی
     * @throws InvalidDriverConfigurationException اگر گیرنده‌ای مشخص نشده باشد
     */
    public function checkStatus(): array
    {
        try {
            $targets = $this->resolveTargets();

            if (empty($targets)) {
                throw new InvalidDriverConfigurationException(
                    'No recipients provided to check status.',
                );
            }

            return $this->fetchStatusForTargets($targets);
        } finally {
            // ریست state حتی در صورت بروز خطا
            $this->reset();
        }
    }

    /**
     * بررسی وضعیت تحویل برای لیست شماره‌ها.
     *
     * مراحل برای هر شماره:
     * ─────────────────────
     * ۱. جستجوی رکوردهای checkable (PENDING/SENT) در دیتابیس
     * ۲. برای هر رکورد:
     *    a. بررسی وجود provider_message_id
     *    b. ساخت درایور مربوطه
     *    c. بررسی پشتیبانی از DeliveryReportFetcher
     *    d. فراخوانی fetchDeliveryReport
     *    e. به‌روزرسانی وضعیت در دیتابیس (اگر تغییر کرده باشد)
     *    f. ثبت نتیجه در آرایه‌ی results
     *
     * @param array<int, string> $phoneNumbers لیست شماره‌ها
     * @return array<int, array<string, mixed>> نتایج بررسی
     */
    protected function fetchStatusForTargets(array $phoneNumbers): array
    {
        /** @var class-string<Sms> $modelClass */
        $modelClass = config('sms.model', Sms::class);

        $results = [];

        foreach ($phoneNumbers as $phone) {
            // ── پیدا کردن رکوردهای قابل بررسی ──
            // فقط PENDING و SENT — وضعیت‌های نهایی نیاز به بررسی ندارند
            $records = $modelClass::query()
                ->forPhone($phone)
                ->checkable()
                ->get();

            foreach ($records as $record) {
                $results[] = $this->checkSingleRecord($record);
            }
        }

        return $results;
    }

    /**
     * بررسی وضعیت تحویل یک رکورد پیامک.
     *
     * این متد یک رکورد واحد را بررسی می‌کند و نتیجه را برمی‌گرداند.
     * تمام خطاها catch می‌شوند تا یک رکورد خراب، بقیه را متوقف نکند.
     *
     * سناریوهای ممکن:
     * ─────────────────
     * ۱. بدون provider_message_id → skip (نمی‌دانیم از سرویس‌دهنده چه بپرسیم)
     * ۲. درایور DeliveryReportFetcher نیست → skip (قابلیت ندارد)
     * ۳. خطا در resolve درایور یا فراخوانی API → error
     * ۴. وضعیت جدید دریافت شد → به‌روزرسانی رکورد + گزارش
     *
     * @param Sms $record رکورد پیامک
     * @return array<string, mixed> نتیجه‌ی بررسی
     */
    protected function checkSingleRecord(Sms $record): array
    {
        // ── ساختار پایه‌ی نتیجه ──
        // این فیلدها همیشه در خروجی هستند (برای ردیابی)
        $baseResult = [
            'sms_id'              => $record->id,
            'phone'               => $record->phone,
            'driver'              => $record->driver,
            'provider_message_id' => $record->provider_message_id,
            'old_status'          => $record->status->value,
        ];

        // ── بررسی ۱: آیا provider_message_id وجود دارد؟ ──
        // بدون این شناسه، نمی‌توانیم از سرویس‌دهنده وضعیت بپرسیم
        if (! $record->hasProviderMessageId()) {
            return array_merge($baseResult, [
                'skipped' => true,
                'reason'  => 'No provider_message_id available.',
            ]);
        }

        try {
            // ── بررسی ۲: ساخت درایور ──
            $driver = $this->resolveDriver($record->driver);

            // ── بررسی ۳: آیا درایور از Delivery Report پشتیبانی می‌کند؟ ──
            if (! $driver instanceof DeliveryReportFetcher) {
                return array_merge($baseResult, [
                    'skipped' => true,
                    'reason'  => 'Driver does not support delivery reports.',
                ]);
            }

            // ── بررسی ۴: استعلام وضعیت از سرویس‌دهنده ──
            $report = $driver->fetchDeliveryReport($record->provider_message_id);

            // استخراج وضعیت جدید از پاسخ درایور
            $newStatus = $report['status'] ?? 'unknown';

            // ── به‌روزرسانی رکورد در دیتابیس ──
            $this->updateRecordStatus($record, $newStatus);

            return array_merge($baseResult, [
                'new_status' => $newStatus,
            ]);

        } catch (\Throwable $e) {
            // ── خطا: ثبت در نتیجه بدون توقف بقیه ──
            // هر نوع خطایی (ارتباطی، config، و ...) اینجا گرفته می‌شود
            // تا بررسی بقیه‌ی رکوردها ادامه پیدا کند
            return array_merge($baseResult, [
                'error' => $e->getMessage(),
            ]);
        }
    }

    /**
     * به‌روزرسانی وضعیت رکورد بر اساس گزارش سرویس‌دهنده.
     *
     * وضعیت‌های شناخته‌شده:
     * ─────────────────────
     * - 'delivered' → markAsDelivered()
     * - 'failed'    → markAsFailed()
     * - سایر مقادیر → نادیده گرفته می‌شوند (وضعیت تغییر نمی‌کند)
     *
     * چرا فقط delivered و failed؟
     * - این دو وضعیت نهایی (terminal) هستند
     * - وضعیت‌های واسط مثل 'queued' یا 'sending' معنادار نیستند
     *   چون رکورد ما قبلاً SENT است
     * - 'unknown' هم تغییری ایجاد نمی‌کند
     *
     * @param Sms    $record    رکورد پیامک
     * @param string $newStatus وضعیت جدید از سرویس‌دهنده
     */
    protected function updateRecordStatus(Sms $record, string $newStatus): void
    {
        // فقط وضعیت‌های نهایی شناخته‌شده باعث به‌روزرسانی می‌شوند
        match ($newStatus) {
            'delivered' => $record->markAsDelivered(),
            'failed'    => $record->markAsFailed('Reported as failed by provider.'),
            default     => null, // وضعیت ناشناخته — بدون تغییر
        };
    }

    // ═══════════════════════════════════════════════════════
    //  RESOLVE — تبدیل ورودی‌های Builder به مقادیر نهایی
    // ═══════════════════════════════════════════════════════

    protected function resolveTargets(): array
    {
        return array_values(array_unique($this->toNumbers));
    }

    protected function resolveMessage(): ?string
    {
        if ($this->messageText !== null) {
            return $this->messageText;
        }

        if ($this->templateText !== null) {
            return $this->compileTemplate($this->templateText, $this->inputs);
        }

        return null;
    }

    protected function compileTemplate(string $template, array $inputs = []): string
    {
        if (empty($inputs)) {
            return $template;
        }

        $search  = [];
        $replace = [];

        foreach ($inputs as $key => $value) {
            $search[]  = '{' . $key . '}';
            $replace[] = (string) $value;
        }

        return str_replace($search, $replace, $template);
    }

    // ═══════════════════════════════════════════════════════
    //  DRIVER — مدیریت درایورها
    // ═══════════════════════════════════════════════════════

    protected function getDriverOrder(): array
    {
        $default  = config('sms.default');
        $failover = config('sms.failover', []);

        $order = [];

        if (! empty($default)) {
            $order[] = $default;
        }

        if (is_array($failover)) {
            $order = array_merge($order, $failover);
        }

        $order = array_values(array_unique($order));

        if (empty($order)) {
            throw new InvalidDriverConfigurationException(
                'No SMS driver configured. Set SMS_DRIVER in .env or update config/sms.php.',
            );
        }

        return $order;
    }

    protected function resolveDriver(string $name): SmsDriver
    {
        $driverConfig = config("sms.drivers.{$name}");

        if (! is_array($driverConfig) || empty($driverConfig)) {
            throw new InvalidDriverConfigurationException(
                "SMS driver [{$name}] is not defined in config/sms.php.",
            );
        }

        $class = $driverConfig['class'] ?? null;

        if (empty($class) || ! is_string($class)) {
            throw new InvalidDriverConfigurationException(
                "Driver class for [{$name}] is not specified in config/sms.php.",
            );
        }

        if (! class_exists($class)) {
            throw new InvalidDriverConfigurationException(
                "Driver class [{$class}] for [{$name}] does not exist.",
            );
        }

        $credentials = $driverConfig['credentials'] ?? [];

        /** @var SmsDriver $driver */
        $driver = $this->container->make($class, [
            'config' => $credentials,
        ]);

        if (! $driver instanceof SmsDriver) {
            throw new InvalidDriverConfigurationException(
                "Driver [{$class}] must implement " . SmsDriver::class . '.',
            );
        }

        return $driver;
    }

    // ═══════════════════════════════════════════════════════
    //  SEND TO TARGETS — ارسال با Failover
    // ═══════════════════════════════════════════════════════

    protected function sendToTargets(array $phoneNumbers, string $message): void
    {
        $driverOrder   = $this->getDriverOrder();
        $lastException = null;

        foreach ($driverOrder as $driverName) {
            try {
                $driver = $this->resolveDriver($driverName);
                $this->usageHandler->ensureUsable($driverName, $driver);
                $this->sendWithDriver($driverName, $driver, $phoneNumbers, $message);

                return;

            } catch (InvalidDriverConfigurationException $e) {
                $lastException = $e;
                continue;

            } catch (DriverConnectionException $e) {
                $lastException = $e;
                continue;
            }
        }

        throw new DriverNotAvailableException(
            message:  'No SMS drivers are available to send messages.',
            previous: $lastException,
        );
    }

    protected function sendWithDriver(
        string $driverName,
        SmsDriver $driver,
        array $phoneNumbers,
        string $message,
    ): void {
        /** @var class-string<Sms> $modelClass */
        $modelClass = config('sms.model', Sms::class);

        foreach ($phoneNumbers as $phoneNumber) {
            /** @var Sms $record */
            $record = $modelClass::create([
                'driver'   => $driverName,
                'template' => $this->templateName,
                'inputs'   => ! empty($this->inputs) ? $this->inputs : null,
                'phone'    => $phoneNumber,
                'message'  => $message,
                'status'   => SmsSendStatusEnum::PENDING,
            ]);

            try {
                $driver->send($phoneNumber, $message);
                $record->markAsSent();

            } catch (DriverConnectionException $e) {
                $record->markAsFailed($e->getMessage());
                throw $e;
            }
        }
    }

    // ═══════════════════════════════════════════════════════
    //  USAGE HANDLER
    // ═══════════════════════════════════════════════════════

    protected function resolveUsageHandler(): SmsUsageHandler
    {
        if ($this->container->bound(SmsUsageHandler::class)) {
            return $this->container->make(SmsUsageHandler::class);
        }

        return new \Karnoweb\SmsSender\Support\NullUsageHandler();
    }

    // ═══════════════════════════════════════════════════════
    //  RESET
    // ═══════════════════════════════════════════════════════

    protected function reset(): void
    {
        $this->toNumbers    = [];
        $this->messageText  = null;
        $this->templateText = null;
        $this->templateName = null;
        $this->inputs       = [];
    }
}
```

---

## ۲. درایور تستی با Delivery Report

`tests/Fakes/DeliveryReportDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;

/**
 * درایور تستی که هم ارسال و هم Delivery Report را پشتیبانی می‌کند.
 *
 * رفتار قابل تنظیم:
 * ──────────────────
 * - ارسال‌ها در $sent ذخیره می‌شوند
 * - پاسخ Delivery Report از $deliveryReports خوانده می‌شود
 * - provider_message_id به صورت خودکار تولید می‌شود
 *
 * نکته: از static استفاده شده تا بین instance های مختلف (resolve توسط Container)
 *        داده‌ها مشترک باشند.
 */
class DeliveryReportDriver implements SmsDriver, DeliveryReportFetcher
{
    /**
     * لیست پیامک‌های ارسال‌شده.
     *
     * @var array<int, array{phone: string, message: string, provider_message_id: string}>
     */
    public static array $sent = [];

    /**
     * پاسخ‌های از پیش تعیین‌شده برای Delivery Report.
     * کلید: provider_message_id — مقدار: آرایه‌ی پاسخ
     *
     * @var array<string, array{status: string}>
     */
    public static array $deliveryReports = [];

    /**
     * شمارنده برای تولید provider_message_id یکتا.
     */
    private static int $counter = 0;

    public function __construct(protected readonly array $config = []) {}

    /**
     * ریست تمام داده‌های استاتیک — باید قبل از هر تست فراخوانی شود.
     */
    public static function reset(): void
    {
        static::$sent            = [];
        static::$deliveryReports = [];
        static::$counter         = 0;
    }

    /**
     * ارسال پیامک و ذخیره‌ی اطلاعات.
     *
     * provider_message_id به صورت خودکار تولید می‌شود
     * تا بعداً در checkStatus قابل استفاده باشد.
     */
    public function send(string $phone, string $message): void
    {
        $providerMessageId = 'msg_' . (++static::$counter);

        static::$sent[] = [
            'phone'               => $phone,
            'message'             => $message,
            'provider_message_id' => $providerMessageId,
        ];
    }

    /**
     * دریافت وضعیت تحویل بر اساس provider_message_id.
     *
     * اگر پاسخ از پیش تعیین شده باشد، آن را برمی‌گرداند.
     * در غیر این صورت 'unknown' برمی‌گرداند.
     */
    public function fetchDeliveryReport(string $providerMessageId): array
    {
        // اگر پاسخ از پیش تعریف شده باشد
        if (isset(static::$deliveryReports[$providerMessageId])) {
            return static::$deliveryReports[$providerMessageId];
        }

        // پیش‌فرض: وضعیت ناشناخته
        return ['status' => 'unknown'];
    }

    /**
     * آخرین provider_message_id تولید‌شده.
     * مفید برای ست‌کردن delivery report بعد از ارسال.
     */
    public static function lastProviderMessageId(): ?string
    {
        if (empty(static::$sent)) {
            return null;
        }

        return end(static::$sent)['provider_message_id'];
    }
}
```

---

## ۳. درایور تستی با Delivery Report خطادار

`tests/Fakes/FailingDeliveryReportDriver.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Fakes;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Exceptions\DriverConnectionException;

/**
 * درایور تستی که در fetchDeliveryReport خطا می‌دهد.
 *
 * برای تست اینکه خطای Delivery Report:
 * - بقیه‌ی رکوردها را متوقف نمی‌کند
 * - در خروجی با کلید 'error' گزارش می‌شود
 */
class FailingDeliveryReportDriver implements SmsDriver, DeliveryReportFetcher
{
    public function __construct(protected readonly array $config = []) {}

    public function send(string $phone, string $message): void
    {
        // ارسال موفق
    }

    public function fetchDeliveryReport(string $providerMessageId): array
    {
        throw new DriverConnectionException(
            'Delivery report API is unavailable.',
        );
    }
}
```

---

## ۴. `tests/Unit/SmsManager/CheckStatusTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\SmsManager;

use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\SmsManager;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های واحد checkStatus — بررسی رفتار بدون درایور واقعی.
 */
class CheckStatusTest extends TestCase
{
    // ─── Validation ────────────────────────────────────────

    public function test_check_status_without_recipients_throws_exception(): void
    {
        $this->expectException(InvalidDriverConfigurationException::class);
        $this->expectExceptionMessage('No recipients');

        Sms::checkStatus();
    }

    // ─── State Reset ───────────────────────────────────────

    public function test_state_resets_after_check_status(): void
    {
        // اول: ست کردن شماره
        try {
            Sms::number('09120000000')->checkStatus();
        } catch (\Throwable) {
            // ممکن است خطا بدهد — مهم نیست
        }

        // state باید پاک شده باشد
        $this->expectException(InvalidDriverConfigurationException::class);
        $this->expectExceptionMessage('No recipients');

        Sms::checkStatus();
    }

    public function test_state_resets_even_after_exception(): void
    {
        try {
            Sms::checkStatus(); // بدون شماره → Exception
        } catch (InvalidDriverConfigurationException) {
            // انتظار داریم
        }

        // تلاش دوبار بدون شماره — state باید پاک باشد
        $this->expectException(InvalidDriverConfigurationException::class);
        Sms::checkStatus();
    }

    // ─── Fluent API ────────────────────────────────────────

    public function test_check_status_uses_same_number_api_as_send(): void
    {
        // اطمینان از اینکه number() و numbers() هم برای checkStatus کار می‌کنند
        $manager = $this->app->make(SmsManager::class);

        $reflection = new \ReflectionProperty(SmsManager::class, 'toNumbers');

        $manager->number('09120000000')->numbers(['09130000000']);

        $this->assertEquals(
            ['09120000000', '09130000000'],
            $reflection->getValue($manager),
        );
    }
}
```

---

## ۵. `tests/Feature/DeliveryReportTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Feature;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Facades\Sms;
use Karnoweb\SmsSender\Models\Sms as SmsModel;
use Karnoweb\SmsSender\Tests\Fakes\DeliveryReportDriver;
use Karnoweb\SmsSender\Tests\Fakes\FailingDeliveryReportDriver;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های یکپارچه‌ی Delivery Report.
 *
 * سناریوها:
 * ──────────
 * ۱. رکورد بدون provider_message_id → skip
 * ۲. درایور بدون پشتیبانی از Delivery Report → skip
 * ۳. وضعیت delivered → به‌روزرسانی رکورد
 * ۴. وضعیت failed → به‌روزرسانی رکورد
 * ۵. وضعیت unknown → بدون تغییر
 * ۶. خطای درایور → ثبت error بدون توقف
 * ۷. رکوردهای terminal نادیده گرفته می‌شوند
 * ۸. چند شماره به صورت همزمان
 * ۹. ریست state بعد از checkStatus
 */
class DeliveryReportTest extends TestCase
{
    use RefreshDatabase;

    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');
    }

    protected function setUp(): void
    {
        parent::setUp();

        DeliveryReportDriver::reset();
    }

    /**
     * Helper: ساخت رکورد پیامک در دیتابیس.
     */
    private function createSmsRecord(array $overrides = []): SmsModel
    {
        return SmsModel::create(array_merge([
            'driver'              => 'delivery_driver',
            'phone'               => '09120000000',
            'message'             => 'Test',
            'status'              => SmsSendStatusEnum::SENT,
            'provider_message_id' => 'msg_test_1',
        ], $overrides));
    }

    /**
     * Helper: ثبت درایور تستی در config.
     */
    private function registerDeliveryDriver(): void
    {
        config([
            'sms.drivers.delivery_driver' => [
                'class'       => DeliveryReportDriver::class,
                'credentials' => [],
            ],
        ]);
    }

    /**
     * Helper: ثبت درایور خطادار در config.
     */
    private function registerFailingDeliveryDriver(): void
    {
        config([
            'sms.drivers.failing_delivery' => [
                'class'       => FailingDeliveryReportDriver::class,
                'credentials' => [],
            ],
        ]);
    }

    // ─── Scenario 1: No provider_message_id ────────────────

    public function test_record_without_provider_id_is_skipped(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord([
            'provider_message_id' => null,
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertTrue($results[0]['skipped']);
        $this->assertStringContainsString('provider_message_id', $results[0]['reason']);
    }

    // ─── Scenario 2: Driver without DeliveryReportFetcher ──

    public function test_driver_without_delivery_report_support_is_skipped(): void
    {
        // NullDriver اینترفیس DeliveryReportFetcher را ندارد
        $this->createSmsRecord([
            'driver' => 'null',
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertTrue($results[0]['skipped']);
        $this->assertStringContainsString('does not support', $results[0]['reason']);
    }

    // ─── Scenario 3: Status → delivered ────────────────────

    public function test_delivered_status_updates_record(): void
    {
        $this->registerDeliveryDriver();

        $record = $this->createSmsRecord([
            'provider_message_id' => 'msg_delivered',
        ]);

        // ست‌کردن پاسخ درایور
        DeliveryReportDriver::$deliveryReports['msg_delivered'] = [
            'status' => 'delivered',
        ];

        $results = Sms::number('09120000000')->checkStatus();

        // بررسی نتیجه
        $this->assertCount(1, $results);
        $this->assertEquals('delivered', $results[0]['new_status']);
        $this->assertEquals('sent', $results[0]['old_status']);

        // بررسی به‌روزرسانی دیتابیس
        $fresh = $record->fresh();
        $this->assertSame(SmsSendStatusEnum::DELIVERED, $fresh->status);
        $this->assertArrayHasKey('delivered_at', $fresh->metadata ?? []);
    }

    // ─── Scenario 4: Status → failed ──────────────────────

    public function test_failed_status_updates_record(): void
    {
        $this->registerDeliveryDriver();

        $record = $this->createSmsRecord([
            'provider_message_id' => 'msg_failed',
        ]);

        DeliveryReportDriver::$deliveryReports['msg_failed'] = [
            'status' => 'failed',
        ];

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('failed', $results[0]['new_status']);

        $fresh = $record->fresh();
        $this->assertSame(SmsSendStatusEnum::FAILED, $fresh->status);
        $this->assertStringContainsString('failed by provider', $fresh->metadata['failure_reason']);
    }

    // ─── Scenario 5: Status → unknown (no change) ─────────

    public function test_unknown_status_does_not_change_record(): void
    {
        $this->registerDeliveryDriver();

        $record = $this->createSmsRecord([
            'provider_message_id' => 'msg_unknown',
        ]);

        // پاسخ پیش‌فرض درایور 'unknown' است (چون msg_unknown تعریف نشده)

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('unknown', $results[0]['new_status']);

        // وضعیت در دیتابیس نباید تغییر کرده باشد
        $fresh = $record->fresh();
        $this->assertSame(SmsSendStatusEnum::SENT, $fresh->status);
    }

    // ─── Scenario 6: Driver error → graceful handling ──────

    public function test_driver_error_is_reported_without_stopping(): void
    {
        $this->registerDeliveryDriver();
        $this->registerFailingDeliveryDriver();

        // دو رکورد: یکی با درایور خطادار، یکی با درایور سالم
        $this->createSmsRecord([
            'driver'              => 'failing_delivery',
            'phone'               => '09120000000',
            'provider_message_id' => 'msg_error',
        ]);

        $this->createSmsRecord([
            'driver'              => 'delivery_driver',
            'phone'               => '09120000000',
            'provider_message_id' => 'msg_ok',
        ]);

        DeliveryReportDriver::$deliveryReports['msg_ok'] = [
            'status' => 'delivered',
        ];

        $results = Sms::number('09120000000')->checkStatus();

        // باید ۲ نتیجه باشد — اولی error، دومی موفق
        $this->assertCount(2, $results);

        // پیدا کردن نتیجه‌ی خطادار
        $errorResult = collect($results)->firstWhere('provider_message_id', 'msg_error');
        $this->assertArrayHasKey('error', $errorResult);
        $this->assertStringContainsString('unavailable', $errorResult['error']);

        // پیدا کردن نتیجه‌ی موفق
        $okResult = collect($results)->firstWhere('provider_message_id', 'msg_ok');
        $this->assertEquals('delivered', $okResult['new_status']);
    }

    // ─── Scenario 7: Terminal records are ignored ──────────

    public function test_delivered_records_are_not_checked(): void
    {
        $this->registerDeliveryDriver();

        // رکورد DELIVERED — نباید بررسی شود
        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::DELIVERED,
            'provider_message_id' => 'msg_already_done',
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        // نتیجه باید خالی باشد (رکورد terminal نادیده گرفته شده)
        $this->assertCount(0, $results);
    }

    public function test_failed_records_are_not_checked(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::FAILED,
            'provider_message_id' => 'msg_already_failed',
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(0, $results);
    }

    public function test_pending_records_are_checked(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::PENDING,
            'provider_message_id' => 'msg_pending',
        ]);

        DeliveryReportDriver::$deliveryReports['msg_pending'] = [
            'status' => 'delivered',
        ];

        $results = Sms::number('09120000000')->checkStatus();

        $this->assertCount(1, $results);
        $this->assertEquals('delivered', $results[0]['new_status']);
    }

    // ─── Scenario 8: Multiple phone numbers ────────────────

    public function test_check_status_for_multiple_numbers(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord([
            'phone'               => '09120000000',
            'provider_message_id' => 'msg_a',
        ]);

        $this->createSmsRecord([
            'phone'               => '09130000000',
            'provider_message_id' => 'msg_b',
        ]);

        // شماره‌ای که رکورد ندارد
        // '09140000000' — نتیجه‌ای ندارد

        DeliveryReportDriver::$deliveryReports['msg_a'] = ['status' => 'delivered'];
        DeliveryReportDriver::$deliveryReports['msg_b'] = ['status' => 'failed'];

        $results = Sms::numbers(['09120000000', '09130000000', '09140000000'])
            ->checkStatus();

        // فقط ۲ نتیجه (شماره‌ی سوم رکوردی ندارد)
        $this->assertCount(2, $results);

        $resultA = collect($results)->firstWhere('phone', '09120000000');
        $resultB = collect($results)->firstWhere('phone', '09130000000');

        $this->assertEquals('delivered', $resultA['new_status']);
        $this->assertEquals('failed', $resultB['new_status']);
    }

    // ─── Scenario 9: State reset ───────────────────────────

    public function test_state_resets_after_check_status(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord();

        Sms::number('09120000000')->checkStatus();

        // فراخوانی بعدی بدون شماره باید خطا بدهد
        $this->expectException(\Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException::class);
        Sms::checkStatus();
    }

    // ─── Scenario 10: Mixed statuses ───────────────────────

    public function test_mixed_records_handled_correctly(): void
    {
        $this->registerDeliveryDriver();

        // ── رکورد ۱: SENT + provider_id + delivered ──
        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::SENT,
            'provider_message_id' => 'msg_1',
        ]);

        // ── رکورد ۲: PENDING + بدون provider_id → skip ──
        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::PENDING,
            'provider_message_id' => null,
        ]);

        // ── رکورد ۳: DELIVERED → نادیده گرفته می‌شود ──
        $this->createSmsRecord([
            'status'              => SmsSendStatusEnum::DELIVERED,
            'provider_message_id' => 'msg_3',
        ]);

        DeliveryReportDriver::$deliveryReports['msg_1'] = ['status' => 'delivered'];

        $results = Sms::number('09120000000')->checkStatus();

        // رکورد ۱: delivered, رکورد ۲: skipped, رکورد ۳: نادیده
        $this->assertCount(2, $results);

        $delivered = collect($results)->firstWhere('provider_message_id', 'msg_1');
        $skipped   = collect($results)->firstWhere('provider_message_id', null);

        $this->assertEquals('delivered', $delivered['new_status']);
        $this->assertTrue($skipped['skipped']);
    }

    // ─── Scenario 11: Empty results for unknown phone ──────

    public function test_no_records_returns_empty_results(): void
    {
        // شماره‌ای که هیچ رکوردی ندارد
        $results = Sms::number('09999999999')->checkStatus();

        $this->assertIsArray($results);
        $this->assertEmpty($results);
    }

    // ─── Scenario 12: Result structure ─────────────────────

    public function test_result_structure_for_successful_check(): void
    {
        $this->registerDeliveryDriver();

        $record = $this->createSmsRecord([
            'provider_message_id' => 'msg_struct',
        ]);

        DeliveryReportDriver::$deliveryReports['msg_struct'] = ['status' => 'delivered'];

        $results = Sms::number('09120000000')->checkStatus();

        $result = $results[0];

        // بررسی وجود تمام فیلدهای مورد انتظار
        $this->assertArrayHasKey('sms_id', $result);
        $this->assertArrayHasKey('phone', $result);
        $this->assertArrayHasKey('driver', $result);
        $this->assertArrayHasKey('provider_message_id', $result);
        $this->assertArrayHasKey('old_status', $result);
        $this->assertArrayHasKey('new_status', $result);

        // بررسی مقادیر
        $this->assertEquals($record->id, $result['sms_id']);
        $this->assertEquals('09120000000', $result['phone']);
        $this->assertEquals('delivery_driver', $result['driver']);
        $this->assertEquals('msg_struct', $result['provider_message_id']);
        $this->assertEquals('sent', $result['old_status']);
        $this->assertEquals('delivered', $result['new_status']);
    }

    public function test_result_structure_for_skipped_record(): void
    {
        $this->registerDeliveryDriver();

        $this->createSmsRecord([
            'provider_message_id' => null,
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        $result = $results[0];

        $this->assertArrayHasKey('skipped', $result);
        $this->assertArrayHasKey('reason', $result);
        $this->assertTrue($result['skipped']);
        $this->assertArrayNotHasKey('new_status', $result);
        $this->assertArrayNotHasKey('error', $result);
    }

    public function test_result_structure_for_error(): void
    {
        $this->registerFailingDeliveryDriver();

        $this->createSmsRecord([
            'driver'              => 'failing_delivery',
            'provider_message_id' => 'msg_err',
        ]);

        $results = Sms::number('09120000000')->checkStatus();

        $result = $results[0];

        $this->assertArrayHasKey('error', $result);
        $this->assertArrayNotHasKey('new_status', $result);
        $this->assertArrayNotHasKey('skipped', $result);
    }
}
```

---

## ۶. به‌روزرسانی `src/Facades/Sms.php`

```php
<?php

namespace Karnoweb\SmsSender\Facades;

use Illuminate\Support\Facades\Facade;
use Karnoweb\SmsSender\SmsManager;

/**
 * Facade برای دسترسی ساده به SmsManager.
 *
 * @method static SmsManager message(string $message)
 * @method static SmsManager otp(\Karnoweb\SmsSender\Enums\SmsTemplateEnum $template)
 * @method static SmsManager input(string $key, string $value)
 * @method static SmsManager inputs(array $inputs)
 * @method static SmsManager number(string $phone)
 * @method static SmsManager numbers(array $phones)
 * @method static void send()
 * @method static array checkStatus()
 *
 * @see SmsManager
 */
class Sms extends Facade
{
    protected static function getFacadeAccessor(): string
    {
        return SmsManager::class;
    }
}
```

---

## ✅ چک‌لیست فاز ۵

| آیتم | وضعیت |
|---|---|
| `checkStatus()` — validation گیرنده‌ها | ✅ |
| `checkStatus()` — ریست state با try/finally | ✅ |
| `fetchStatusForTargets()` — حلقه روی شماره‌ها و رکوردها | ✅ |
| `checkSingleRecord()` — skip بدون provider_message_id | ✅ |
| `checkSingleRecord()` — skip درایور بدون DeliveryReportFetcher | ✅ |
| `checkSingleRecord()` — فراخوانی fetchDeliveryReport | ✅ |
| `checkSingleRecord()` — catch تمام Throwable ها | ✅ |
| `updateRecordStatus()` — delivered → markAsDelivered | ✅ |
| `updateRecordStatus()` — failed → markAsFailed | ✅ |
| `updateRecordStatus()` — unknown → بدون تغییر | ✅ |
| `DeliveryReportDriver` — Fake Driver برای تست | ✅ |
| `FailingDeliveryReportDriver` — Fake Driver خطادار | ✅ |
| تست Unit — validation، state reset، fluent API | ✅ |
| تست Feature — ۱۲ سناریو جامع | ✅ |
| تست ساختار خروجی (success, skipped, error) | ✅ |
| تست رکوردهای terminal نادیده گرفته می‌شوند | ✅ |
| تست چند شماره همزمان | ✅ |
| تست ترکیب وضعیت‌های مختلف | ✅ |
| کامنت‌های فارسی جامع | ✅ |

---

**فاز ۵ کامل شد.** بریم فاز ۶ (SmsUsageHandler — کنترل مصرف و محدودیت)؟