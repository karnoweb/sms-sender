

# فاز ۳ — مدل، Migration و Enum

## ساختار فایل‌های جدید

```
src/
├── Enums/
│   ├── SmsSendStatusEnum.php          ← جدید
│   └── SmsTemplateEnum.php            ← جدید (قالب‌های OTP/سیستمی)
├── Models/
│   └── Sms.php                        ← جدید
database/
└── migrations/
    └── 2025_01_01_000000_create_sms_messages_table.php  ← جدید
tests/
└── Unit/
    ├── Enums/
    │   ├── SmsSendStatusEnumTest.php
    │   └── SmsTemplateEnumTest.php
    └── Models/
        └── SmsModelTest.php
```

---

## ۱. `src/Enums/SmsSendStatusEnum.php`

```php
<?php

namespace Karnoweb\SmsSender\Enums;

/**
 * وضعیت‌های ممکن برای یک رکورد پیامک.
 *
 * چرخه‌ی حیات یک پیامک:
 * ─────────────────────
 *
 *   PENDING ──► SENT ──► DELIVERED
 *     │           │
 *     │           └──► FAILED (بعد از ارسال، سرویس‌دهنده خطا گزارش داد)
 *     │
 *     └──► FAILED (خطا قبل/حین ارسال)
 *
 * توضیح هر وضعیت:
 * ───────────────
 * - PENDING:   رکورد ساخته شده ولی هنوز به درایور ارسال نشده
 * - SENT:      درایور ارسال را تأیید کرده (اما تحویل تضمین نیست)
 * - DELIVERED:  سرویس‌دهنده تحویل به گیرنده را تأیید کرده
 * - FAILED:    ارسال یا تحویل با شکست مواجه شده
 *
 * نکته: مقادیر به صورت string هستند (نه int) تا خوانایی در دیتابیس بیشتر باشد
 * و در کوئری‌ها و لاگ‌ها بدون نیاز به mapping قابل درک باشند.
 */
enum SmsSendStatusEnum: string
{
    /**
     * رکورد ایجاد شده، منتظر ارسال توسط درایور.
     * این وضعیت اولیه‌ی هر پیامک است.
     */
    case PENDING = 'pending';

    /**
     * درایور ارسال را با موفقیت انجام داده.
     * پیامک به سرویس‌دهنده تحویل شده ولی هنوز تأیید تحویل به گیرنده نیامده.
     */
    case SENT = 'sent';

    /**
     * سرویس‌دهنده تأیید کرده که پیامک به گوشی گیرنده تحویل شده.
     * این وضعیت فقط از طریق Delivery Report (checkStatus) به‌روزرسانی می‌شود.
     */
    case DELIVERED = 'delivered';

    /**
     * ارسال یا تحویل پیامک با شکست مواجه شده.
     * ممکن است در مرحله‌ی ارسال به درایور یا بعد از آن (گزارش سرویس‌دهنده) رخ دهد.
     */
    case FAILED = 'failed';

    /**
     * برچسب فارسی هر وضعیت برای نمایش در UI یا گزارش‌ها.
     */
    public function label(): string
    {
        return match ($this) {
            self::PENDING   => 'در انتظار ارسال',
            self::SENT      => 'ارسال شده',
            self::DELIVERED => 'تحویل داده شده',
            self::FAILED    => 'ناموفق',
        };
    }

    /**
     * آیا این وضعیت یک وضعیت نهایی (Terminal) است؟
     *
     * وضعیت‌های نهایی دیگر تغییر نمی‌کنند و نیازی به بررسی مجدد ندارند.
     * در checkStatus() فقط وضعیت‌های غیرنهایی بررسی می‌شوند.
     */
    public function isTerminal(): bool
    {
        return match ($this) {
            self::DELIVERED, self::FAILED => true,
            default => false,
        };
    }

    /**
     * وضعیت‌هایی که هنوز قابل بررسی (checkable) هستند.
     *
     * استفاده در checkStatus():
     *   ->whereIn('status', SmsSendStatusEnum::checkable())
     *
     * @return array<int, self>
     */
    public static function checkable(): array
    {
        return [
            self::PENDING,
            self::SENT,
        ];
    }
}
```

---

## ۲. `src/Enums/SmsTemplateEnum.php`

```php
<?php

namespace Karnoweb\SmsSender\Enums;

/**
 * قالب‌های از پیش تعریف‌شده‌ی پیامک.
 *
 * هر case یک قالب OTP یا سیستمی است که مقدارش (value)
 * متن قالب با placeholder های {} است.
 *
 * استفاده:
 * ```php
 * Sms::otp(SmsTemplateEnum::LOGIN_OTP)
 *     ->input('code', '1234')
 *     ->number('09120000000')
 *     ->send();
 * ```
 *
 * نکته: این Enum قابل گسترش توسط اپلیکیشن نیست (محدودیت PHP Enum).
 * اگر نیاز به قالب‌های پویا دارید، از متد template() یا message() استفاده کنید.
 *
 * برای سفارشی‌سازی قالب‌ها، می‌توانید:
 * ۱. این فایل را در پروژه‌ی خود کپی و تغییر دهید.
 * ۲. یا از قالب‌های دیتابیسی (NotificationTemplate) استفاده کنید.
 */
enum SmsTemplateEnum: string
{
    /**
     * قالب ورود با رمز یکبار مصرف.
     * Placeholder: {code}
     */
    case LOGIN_OTP = 'کد ورود شما: {code}';

    /**
     * قالب تأیید شماره موبایل.
     * Placeholder: {code}
     */
    case VERIFY_PHONE = 'کد تأیید شماره: {code}';

    /**
     * قالب بازیابی رمز عبور.
     * Placeholder: {code}
     */
    case PASSWORD_RESET = 'کد بازیابی رمز عبور: {code}';

    /**
     * استخراج لیست placeholder های یک قالب.
     *
     * مثال:
     *   SmsTemplateEnum::LOGIN_OTP->placeholders() // ['code']
     *
     * @return array<int, string>
     */
    public function placeholders(): array
    {
        preg_match_all('/\{(\w+)}/', $this->value, $matches);

        return $matches[1] ?? [];
    }
}
```

---

## ۳. `src/Models/Sms.php`

```php
<?php

namespace Karnoweb\SmsSender\Models;

use Illuminate\Database\Eloquent\Model;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;

/**
 * مدل لاگ پیامک‌های ارسالی.
 *
 * هر رکورد نماینده‌ی یک تلاش ارسال پیامک به یک شماره‌ی مشخص است.
 * اگر پیامک به ۳ شماره ارسال شود، ۳ رکورد ساخته می‌شود.
 *
 * این مدل توسط SmsManager برای موارد زیر استفاده می‌شود:
 * ─────────────────────────────────────────────────────────
 * ۱. ثبت لاگ قبل از ارسال (با وضعیت PENDING)
 * ۲. به‌روزرسانی وضعیت بعد از ارسال (SENT یا FAILED)
 * ۳. بررسی وضعیت تحویل (checkStatus) بر اساس provider_message_id
 * ۴. گزارش‌گیری و آمار ارسال
 *
 * جدول پیش‌فرض: sms_messages (قابل تغییر از config)
 *
 * @property int                 $id
 * @property string              $driver                 نام درایور (مثلاً 'kavenegar')
 * @property string|null         $template               نام قالب استفاده‌شده (مثلاً 'LOGIN_OTP')
 * @property array|null          $inputs                 ورودی‌های قالب (JSON)
 * @property string              $phone                  شماره‌ی گیرنده
 * @property string              $message                متن نهایی ارسال‌شده
 * @property string|null         $provider_message_id    شناسه‌ی پیامک در سرویس‌دهنده (برای Delivery Report)
 * @property SmsSendStatusEnum   $status                 وضعیت فعلی پیامک
 * @property array|null          $metadata               اطلاعات اضافی (پاسخ API، خطا و ...)
 * @property \Carbon\Carbon      $created_at
 * @property \Carbon\Carbon      $updated_at
 */
class Sms extends Model
{
    /**
     * نام جدول از config خوانده می‌شود تا کاربر بتواند آن را تغییر دهد.
     *
     * اگر config در دسترس نباشد (مثلاً در تست بدون boot)
     * مقدار پیش‌فرض 'sms_messages' استفاده می‌شود.
     */
    public function getTable(): string
    {
        return config('sms.table', 'sms_messages');
    }

    /**
     * فیلدهای قابل پر شدن (Mass Assignment).
     *
     * نکته: 'id', 'created_at', 'updated_at' توسط Eloquent مدیریت می‌شوند
     * و نباید در $fillable باشند.
     */
    protected $fillable = [
        'driver',
        'template',
        'inputs',
        'phone',
        'message',
        'provider_message_id',
        'status',
        'metadata',
    ];

    /**
     * Cast های Eloquent.
     *
     * - inputs و metadata به صورت JSON در دیتابیس ذخیره و به array تبدیل می‌شوند.
     * - status به Enum cast می‌شود تا همیشه type-safe باشد.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'inputs'   => 'array',
            'metadata' => 'array',
            'status'   => SmsSendStatusEnum::class,
        ];
    }

    // ─── Query Scopes ──────────────────────────────────────

    /**
     * فیلتر پیامک‌هایی که هنوز وضعیت نهایی ندارند.
     *
     * استفاده در checkStatus():
     *   Sms::checkable()->where('phone', $phone)->get();
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     */
    public function scopeCheckable($query)
    {
        return $query->whereIn('status', SmsSendStatusEnum::checkable());
    }

    /**
     * فیلتر بر اساس درایور مشخص.
     *
     * مثال: Sms::forDriver('kavenegar')->count();
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     */
    public function scopeForDriver($query, string $driverName)
    {
        return $query->where('driver', $driverName);
    }

    /**
     * فیلتر بر اساس شماره‌ی گیرنده.
     *
     * مثال: Sms::forPhone('09120000000')->latest()->first();
     *
     * @param \Illuminate\Database\Eloquent\Builder $query
     */
    public function scopeForPhone($query, string $phone)
    {
        return $query->where('phone', $phone);
    }

    // ─── Helpers ───────────────────────────────────────────

    /**
     * آیا وضعیت پیامک نهایی (Terminal) است؟
     *
     * پیامک‌های با وضعیت نهایی دیگر تغییر نمی‌کنند.
     */
    public function isTerminal(): bool
    {
        return $this->status->isTerminal();
    }

    /**
     * آیا این پیامک شناسه‌ی سرویس‌دهنده دارد؟
     *
     * بدون provider_message_id امکان بررسی Delivery Report وجود ندارد.
     */
    public function hasProviderMessageId(): bool
    {
        return ! empty($this->provider_message_id);
    }

    /**
     * علامت‌گذاری به عنوان ارسال‌شده.
     *
     * @param string|null $providerMessageId شناسه‌ی برگردانده‌شده از سرویس‌دهنده
     */
    public function markAsSent(?string $providerMessageId = null): bool
    {
        $data = ['status' => SmsSendStatusEnum::SENT];

        if ($providerMessageId !== null) {
            $data['provider_message_id'] = $providerMessageId;
        }

        return $this->update($data);
    }

    /**
     * علامت‌گذاری به عنوان ناموفق.
     *
     * @param string|null $reason دلیل شکست برای ذخیره در metadata
     */
    public function markAsFailed(?string $reason = null): bool
    {
        $data = ['status' => SmsSendStatusEnum::FAILED];

        if ($reason !== null) {
            $data['metadata'] = array_merge($this->metadata ?? [], [
                'failure_reason' => $reason,
                'failed_at'      => now()->toDateTimeString(),
            ]);
        }

        return $this->update($data);
    }

    /**
     * علامت‌گذاری به عنوان تحویل‌شده.
     */
    public function markAsDelivered(): bool
    {
        return $this->update([
            'status'   => SmsSendStatusEnum::DELIVERED,
            'metadata' => array_merge($this->metadata ?? [], [
                'delivered_at' => now()->toDateTimeString(),
            ]),
        ]);
    }
}
```

---

## ۴. Migration

`database/migrations/2025_01_01_000000_create_sms_messages_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;

/**
 * ایجاد جدول لاگ پیامک‌ها.
 *
 * این جدول هر تلاش ارسال پیامک را ذخیره می‌کند.
 * نام جدول از config('sms.table') خوانده می‌شود (پیش‌فرض: sms_messages).
 *
 * ایندکس‌ها:
 * ──────────
 * - phone + status: برای checkStatus() که پیامک‌های pending/sent یک شماره را می‌خواهد
 * - driver: برای گزارش‌گیری بر اساس درایور
 * - provider_message_id: برای جستجوی سریع در Delivery Report
 * - created_at: برای مرتب‌سازی و گزارش‌های زمانی
 */
return new class extends Migration
{
    public function up(): void
    {
        $table = config('sms.table', 'sms_messages');

        Schema::create($table, function (Blueprint $table) {

            $table->id();

            // ── اطلاعات درایور و قالب ──────────────────────

            // نام درایور استفاده‌شده (کلید در config، مثلاً 'kavenegar')
            $table->string('driver');

            // نام قالب (مثلاً 'LOGIN_OTP') — nullable چون ممکن است پیام ساده باشد
            $table->string('template')->nullable();

            // ورودی‌های قالب به صورت JSON (مثلاً {"code": "1234"})
            $table->json('inputs')->nullable();

            // ── اطلاعات پیامک ──────────────────────────────

            // شماره‌ی گیرنده
            $table->string('phone');

            // متن نهایی پیامک (بعد از compile شدن قالب)
            $table->text('message');

            // ── ردیابی سرویس‌دهنده ─────────────────────────

            // شناسه‌ی پیامک در سرویس‌دهنده (برای Delivery Report)
            // nullable چون قبل از ارسال هنوز مقدار ندارد
            $table->string('provider_message_id')->nullable();

            // وضعیت فعلی پیامک
            $table->string('status')->default(SmsSendStatusEnum::PENDING->value);

            // ── اطلاعات اضافی ──────────────────────────────

            // metadata برای ذخیره‌ی اطلاعات اضافی مثل پاسخ API، دلیل خطا و ...
            $table->json('metadata')->nullable();

            $table->timestamps();

            // ── ایندکس‌ها ──────────────────────────────────

            // ایندکس ترکیبی: checkStatus() → پیامک‌های pending/sent یک شماره
            $table->index(['phone', 'status']);

            // ایندکس درایور: گزارش‌گیری بر اساس سرویس‌دهنده
            $table->index('driver');

            // ایندکس شناسه‌ی سرویس‌دهنده: جستجوی سریع Delivery Report
            $table->index('provider_message_id');
        });
    }

    public function down(): void
    {
        $table = config('sms.table', 'sms_messages');

        Schema::dropIfExists($table);
    }
};
```

---

## ۵. `tests/Unit/Enums/SmsSendStatusEnumTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Enums;

use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های Enum وضعیت ارسال پیامک.
 */
class SmsSendStatusEnumTest extends TestCase
{
    // ─── Cases ─────────────────────────────────────────────

    public function test_has_all_expected_cases(): void
    {
        $cases = SmsSendStatusEnum::cases();

        // باید دقیقاً ۴ وضعیت داشته باشیم
        $this->assertCount(4, $cases);
    }

    public function test_case_values_are_lowercase_strings(): void
    {
        // مقادیر string باید lowercase باشند برای خوانایی در دیتابیس
        $this->assertEquals('pending', SmsSendStatusEnum::PENDING->value);
        $this->assertEquals('sent', SmsSendStatusEnum::SENT->value);
        $this->assertEquals('delivered', SmsSendStatusEnum::DELIVERED->value);
        $this->assertEquals('failed', SmsSendStatusEnum::FAILED->value);
    }

    public function test_enum_can_be_created_from_value(): void
    {
        // Eloquent از from() برای cast کردن استفاده می‌کند
        $status = SmsSendStatusEnum::from('pending');

        $this->assertSame(SmsSendStatusEnum::PENDING, $status);
    }

    public function test_invalid_value_throws_error(): void
    {
        // مقدار نامعتبر باید ValueError پرتاب کند
        $this->expectException(\ValueError::class);

        SmsSendStatusEnum::from('invalid_status');
    }

    // ─── Labels ────────────────────────────────────────────

    public function test_all_cases_have_labels(): void
    {
        // هر وضعیت باید یک برچسب فارسی داشته باشد
        foreach (SmsSendStatusEnum::cases() as $case) {
            $label = $case->label();

            $this->assertIsString($label);
            $this->assertNotEmpty($label, "Label for {$case->name} must not be empty.");
        }
    }

    public function test_specific_labels(): void
    {
        $this->assertEquals('در انتظار ارسال', SmsSendStatusEnum::PENDING->label());
        $this->assertEquals('ارسال شده', SmsSendStatusEnum::SENT->label());
        $this->assertEquals('تحویل داده شده', SmsSendStatusEnum::DELIVERED->label());
        $this->assertEquals('ناموفق', SmsSendStatusEnum::FAILED->label());
    }

    // ─── Terminal State ────────────────────────────────────

    public function test_terminal_states(): void
    {
        // فقط DELIVERED و FAILED نهایی هستند
        $this->assertTrue(SmsSendStatusEnum::DELIVERED->isTerminal());
        $this->assertTrue(SmsSendStatusEnum::FAILED->isTerminal());
    }

    public function test_non_terminal_states(): void
    {
        // PENDING و SENT هنوز ممکن است تغییر کنند
        $this->assertFalse(SmsSendStatusEnum::PENDING->isTerminal());
        $this->assertFalse(SmsSendStatusEnum::SENT->isTerminal());
    }

    // ─── Checkable ─────────────────────────────────────────

    public function test_checkable_returns_non_terminal_states(): void
    {
        $checkable = SmsSendStatusEnum::checkable();

        $this->assertCount(2, $checkable);
        $this->assertContains(SmsSendStatusEnum::PENDING, $checkable);
        $this->assertContains(SmsSendStatusEnum::SENT, $checkable);
    }

    public function test_checkable_does_not_include_terminal_states(): void
    {
        $checkable = SmsSendStatusEnum::checkable();

        $this->assertNotContains(SmsSendStatusEnum::DELIVERED, $checkable);
        $this->assertNotContains(SmsSendStatusEnum::FAILED, $checkable);
    }
}
```

---

## ۶. `tests/Unit/Enums/SmsTemplateEnumTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Enums;

use Karnoweb\SmsSender\Enums\SmsTemplateEnum;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های Enum قالب‌های پیامک.
 */
class SmsTemplateEnumTest extends TestCase
{
    // ─── Structure ─────────────────────────────────────────

    public function test_all_cases_have_string_values(): void
    {
        // هر case باید یک متن قالب (string) داشته باشد
        foreach (SmsTemplateEnum::cases() as $case) {
            $this->assertIsString($case->value);
            $this->assertNotEmpty($case->value, "Template for {$case->name} must not be empty.");
        }
    }

    public function test_all_templates_contain_placeholders(): void
    {
        // هر قالب باید حداقل یک placeholder داشته باشد
        // (قالب بدون placeholder عملاً پیام ثابت است و نیاز به Enum ندارد)
        foreach (SmsTemplateEnum::cases() as $case) {
            $this->assertMatchesRegularExpression(
                '/\{\w+}/',
                $case->value,
                "Template {$case->name} must contain at least one {placeholder}.",
            );
        }
    }

    // ─── Placeholders ──────────────────────────────────────

    public function test_login_otp_has_code_placeholder(): void
    {
        $placeholders = SmsTemplateEnum::LOGIN_OTP->placeholders();

        $this->assertContains('code', $placeholders);
    }

    public function test_verify_phone_has_code_placeholder(): void
    {
        $placeholders = SmsTemplateEnum::VERIFY_PHONE->placeholders();

        $this->assertContains('code', $placeholders);
    }

    public function test_password_reset_has_code_placeholder(): void
    {
        $placeholders = SmsTemplateEnum::PASSWORD_RESET->placeholders();

        $this->assertContains('code', $placeholders);
    }

    public function test_placeholders_returns_array_of_strings(): void
    {
        foreach (SmsTemplateEnum::cases() as $case) {
            $placeholders = $case->placeholders();

            $this->assertIsArray($placeholders);

            foreach ($placeholders as $placeholder) {
                $this->assertIsString($placeholder);
            }
        }
    }

    // ─── From Value ────────────────────────────────────────

    public function test_can_create_from_value(): void
    {
        $template = SmsTemplateEnum::from('کد ورود شما: {code}');

        $this->assertSame(SmsTemplateEnum::LOGIN_OTP, $template);
    }

    public function test_try_from_returns_null_for_invalid(): void
    {
        $template = SmsTemplateEnum::tryFrom('invalid template');

        $this->assertNull($template);
    }
}
```

---

## ۷. `tests/Unit/Models/SmsModelTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Models;

use Illuminate\Foundation\Testing\RefreshDatabase;
use Karnoweb\SmsSender\Enums\SmsSendStatusEnum;
use Karnoweb\SmsSender\Models\Sms;
use Karnoweb\SmsSender\Tests\TestCase;

/**
 * تست‌های مدل Sms.
 *
 * از RefreshDatabase استفاده می‌کنیم تا هر تست با دیتابیس تمیز اجرا شود.
 * Migration پکیج باید قبل از تست‌ها اجرا شده باشد.
 */
class SmsModelTest extends TestCase
{
    use RefreshDatabase;

    /**
     * اجرای migration های پکیج در محیط تست.
     *
     * Orchestra Testbench از SQLite in-memory استفاده می‌کند.
     */
    protected function defineDatabaseMigrations(): void
    {
        $this->loadMigrationsFrom(__DIR__ . '/../../../database/migrations');
    }

    /**
     * ساخت یک رکورد پیامک نمونه برای تست.
     *
     * @param array<string, mixed> $overrides فیلدهایی که می‌خواهید override کنید
     */
    private function createSms(array $overrides = []): Sms
    {
        return Sms::create(array_merge([
            'driver'  => 'null',
            'phone'   => '09120000000',
            'message' => 'Test message',
            'status'  => SmsSendStatusEnum::PENDING,
        ], $overrides));
    }

    // ─── Basic CRUD ────────────────────────────────────────

    public function test_can_create_sms_record(): void
    {
        $sms = $this->createSms();

        $this->assertDatabaseHas('sms_messages', [
            'id'    => $sms->id,
            'phone' => '09120000000',
        ]);
    }

    public function test_table_name_comes_from_config(): void
    {
        $sms = new Sms();

        $this->assertEquals(
            config('sms.table', 'sms_messages'),
            $sms->getTable(),
        );
    }

    public function test_fillable_fields(): void
    {
        $sms = $this->createSms([
            'driver'              => 'kavenegar',
            'template'            => 'LOGIN_OTP',
            'inputs'              => ['code' => '1234'],
            'phone'               => '09130000000',
            'message'             => 'کد ورود: 1234',
            'provider_message_id' => 'msg_abc123',
            'status'              => SmsSendStatusEnum::SENT,
            'metadata'            => ['response_code' => 200],
        ]);

        $this->assertEquals('kavenegar', $sms->driver);
        $this->assertEquals('LOGIN_OTP', $sms->template);
        $this->assertEquals('09130000000', $sms->phone);
        $this->assertEquals('msg_abc123', $sms->provider_message_id);
    }

    // ─── Casts ─────────────────────────────────────────────

    public function test_status_is_cast_to_enum(): void
    {
        $sms = $this->createSms();

        // بعد از خواندن از دیتابیس، status باید Enum باشد نه string
        $fresh = $sms->fresh();

        $this->assertInstanceOf(SmsSendStatusEnum::class, $fresh->status);
        $this->assertSame(SmsSendStatusEnum::PENDING, $fresh->status);
    }

    public function test_inputs_is_cast_to_array(): void
    {
        $inputs = ['code' => '5678', 'name' => 'علی'];

        $sms = $this->createSms(['inputs' => $inputs]);
        $fresh = $sms->fresh();

        // JSON در دیتابیس ذخیره شده و به array تبدیل می‌شود
        $this->assertIsArray($fresh->inputs);
        $this->assertEquals('5678', $fresh->inputs['code']);
        $this->assertEquals('علی', $fresh->inputs['name']);
    }

    public function test_metadata_is_cast_to_array(): void
    {
        $metadata = ['api_response' => 'OK', 'duration_ms' => 120];

        $sms = $this->createSms(['metadata' => $metadata]);
        $fresh = $sms->fresh();

        $this->assertIsArray($fresh->metadata);
        $this->assertEquals('OK', $fresh->metadata['api_response']);
    }

    public function test_nullable_fields_default_to_null(): void
    {
        $sms = $this->createSms();
        $fresh = $sms->fresh();

        $this->assertNull($fresh->template);
        $this->assertNull($fresh->inputs);
        $this->assertNull($fresh->provider_message_id);
        $this->assertNull($fresh->metadata);
    }

    // ─── Scopes ────────────────────────────────────────────

    public function test_scope_checkable(): void
    {
        // ساخت پیامک‌ها با وضعیت‌های مختلف
        $this->createSms(['phone' => '09121111111', 'status' => SmsSendStatusEnum::PENDING]);
        $this->createSms(['phone' => '09122222222', 'status' => SmsSendStatusEnum::SENT]);
        $this->createSms(['phone' => '09123333333', 'status' => SmsSendStatusEnum::DELIVERED]);
        $this->createSms(['phone' => '09124444444', 'status' => SmsSendStatusEnum::FAILED]);

        // checkable فقط PENDING و SENT را برمی‌گرداند
        $checkable = Sms::checkable()->get();

        $this->assertCount(2, $checkable);
    }

    public function test_scope_for_driver(): void
    {
        $this->createSms(['driver' => 'kavenegar']);
        $this->createSms(['driver' => 'kavenegar']);
        $this->createSms(['driver' => 'melipayamak']);

        $kavenegarCount = Sms::forDriver('kavenegar')->count();
        $meliCount      = Sms::forDriver('melipayamak')->count();

        $this->assertEquals(2, $kavenegarCount);
        $this->assertEquals(1, $meliCount);
    }

    public function test_scope_for_phone(): void
    {
        $this->createSms(['phone' => '09120000000']);
        $this->createSms(['phone' => '09120000000']);
        $this->createSms(['phone' => '09130000000']);

        $count = Sms::forPhone('09120000000')->count();

        $this->assertEquals(2, $count);
    }

    // ─── Helper Methods ────────────────────────────────────

    public function test_is_terminal(): void
    {
        $pending   = $this->createSms(['status' => SmsSendStatusEnum::PENDING]);
        $sent      = $this->createSms(['status' => SmsSendStatusEnum::SENT]);
        $delivered = $this->createSms(['status' => SmsSendStatusEnum::DELIVERED]);
        $failed    = $this->createSms(['status' => SmsSendStatusEnum::FAILED]);

        $this->assertFalse($pending->isTerminal());
        $this->assertFalse($sent->isTerminal());
        $this->assertTrue($delivered->isTerminal());
        $this->assertTrue($failed->isTerminal());
    }

    public function test_has_provider_message_id(): void
    {
        $without = $this->createSms();
        $with    = $this->createSms(['provider_message_id' => 'msg_123']);

        $this->assertFalse($without->hasProviderMessageId());
        $this->assertTrue($with->hasProviderMessageId());
    }

    public function test_mark_as_sent_without_provider_id(): void
    {
        $sms = $this->createSms();
        $sms->markAsSent();

        $fresh = $sms->fresh();

        $this->assertSame(SmsSendStatusEnum::SENT, $fresh->status);
        $this->assertNull($fresh->provider_message_id);
    }

    public function test_mark_as_sent_with_provider_id(): void
    {
        $sms = $this->createSms();
        $sms->markAsSent('msg_xyz789');

        $fresh = $sms->fresh();

        $this->assertSame(SmsSendStatusEnum::SENT, $fresh->status);
        $this->assertEquals('msg_xyz789', $fresh->provider_message_id);
    }

    public function test_mark_as_failed_without_reason(): void
    {
        $sms = $this->createSms();
        $sms->markAsFailed();

        $this->assertSame(SmsSendStatusEnum::FAILED, $sms->fresh()->status);
    }

    public function test_mark_as_failed_with_reason(): void
    {
        $sms = $this->createSms();
        $sms->markAsFailed('Connection timeout');

        $fresh = $sms->fresh();

        $this->assertSame(SmsSendStatusEnum::FAILED, $fresh->status);
        $this->assertEquals('Connection timeout', $fresh->metadata['failure_reason']);
        $this->assertArrayHasKey('failed_at', $fresh->metadata);
    }

    public function test_mark_as_failed_preserves_existing_metadata(): void
    {
        // metadata قبلی نباید پاک شود
        $sms = $this->createSms(['metadata' => ['attempt' => 1]]);
        $sms->markAsFailed('Timeout');

        $fresh = $sms->fresh();

        $this->assertEquals(1, $fresh->metadata['attempt']);
        $this->assertEquals('Timeout', $fresh->metadata['failure_reason']);
    }

    public function test_mark_as_delivered(): void
    {
        $sms = $this->createSms(['status' => SmsSendStatusEnum::SENT]);
        $sms->markAsDelivered();

        $fresh = $sms->fresh();

        $this->assertSame(SmsSendStatusEnum::DELIVERED, $fresh->status);
        $this->assertArrayHasKey('delivered_at', $fresh->metadata);
    }
}
```

---

## ✅ چک‌لیست فاز ۳

| آیتم | وضعیت |
|---|---|
| `SmsSendStatusEnum` — ۴ وضعیت با value، label، isTerminal، checkable | ✅ |
| `SmsTemplateEnum` — قالب‌های OTP با placeholders() | ✅ |
| `Sms` Model — fillable, casts, scopes, helper methods | ✅ |
| `Sms` Model — نام جدول از config | ✅ |
| `Sms` Model — markAsSent, markAsFailed, markAsDelivered | ✅ |
| Migration — تمام فیلدها، ایندکس‌ها، default status | ✅ |
| تست Enum وضعیت — cases, values, labels, terminal, checkable | ✅ |
| تست Enum قالب — structure, placeholders, from/tryFrom | ✅ |
| تست Model — CRUD, casts, scopes, helpers, mark methods | ✅ |
| کامنت‌های فارسی جامع | ✅ |

---

**فاز ۳ کامل شد.** بریم فاز ۴ (هسته‌ی `SmsManager` — Builder, Resolve, Send, Failover)؟