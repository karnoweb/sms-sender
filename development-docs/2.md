

# فاز ۲ — Contracts و Exceptions

## ساختار فایل‌های جدید

```
src/
├── Contracts/
│   ├── SmsDriver.php                  ← تکمیل از فاز ۱
│   ├── DeliveryReportFetcher.php      ← جدید
│   └── SmsUsageHandler.php            ← جدید (قرارداد فقط، پیاده‌سازی فاز ۶)
├── Exceptions/
│   ├── SmsException.php               ← جدید (کلاس پایه)
│   ├── InvalidDriverConfigurationException.php
│   ├── DriverConnectionException.php
│   └── DriverNotAvailableException.php
tests/
├── Unit/
│   ├── Contracts/
│   │   ├── SmsDriverContractTest.php
│   │   └── DeliveryReportFetcherContractTest.php
│   └── Exceptions/
│       └── ExceptionsTest.php
```

---

## ۱. `src/Contracts/SmsDriver.php` (تکمیل‌شده)

```php
<?php

namespace Karnoweb\SmsSender\Contracts;

/**
 * قرارداد اصلی درایورهای SMS.
 *
 * هر درایور ارسال پیامک (کاوه‌نگار، ملی‌پیامک، و ...) باید این اینترفیس را
 * پیاده‌سازی کند تا SmsManager بتواند به صورت یکپارچه از آن استفاده کند.
 *
 * قواعد پیاده‌سازی:
 * ─────────────────
 * ۱. سازنده باید یک پارامتر `array $config` بپذیرد.
 *    این آرایه شامل credentials و تنظیمات از config/sms.php است.
 *
 * ۲. در صورت موفقیت، متد send هیچ مقداری برنمی‌گرداند (void).
 *
 * ۳. در صورت خطای ارتباطی (timeout، DNS، HTTP error و ...)
 *    باید DriverConnectionException پرتاب شود تا مکانیزم Failover فعال شود.
 *
 * ۴. خطاهای غیرمنتظره (bug) نباید catch شوند — باید به بالا bubble کنند
 *    تا سریع‌تر شناسایی شوند.
 *
 * نمونه پیاده‌سازی:
 * ```php
 * class KavenegarDriver implements SmsDriver
 * {
 *     public function __construct(protected readonly array $config) {}
 *
 *     public function send(string $phone, string $message): void
 *     {
 *         try {
 *             // HTTP call to Kavenegar API...
 *         } catch (HttpException $e) {
 *             throw new DriverConnectionException($e->getMessage(), $e->getCode(), $e);
 *         }
 *     }
 * }
 * ```
 */
interface SmsDriver
{
    /**
     * ارسال یک پیامک به شماره‌ی مشخص.
     *
     * @param string $phone   شماره‌ی موبایل گیرنده (مثلاً '09120000000')
     * @param string $message متن نهایی پیامک (بعد از compile شدن template)
     *
     * @throws \Karnoweb\SmsSender\Exceptions\DriverConnectionException در صورت خطای ارتباطی با سرویس‌دهنده
     */
    public function send(string $phone, string $message): void;
}
```

---

## ۲. `src/Contracts/DeliveryReportFetcher.php`

```php
<?php

namespace Karnoweb\SmsSender\Contracts;

/**
 * قرارداد دریافت وضعیت تحویل پیامک (Delivery Report).
 *
 * این اینترفیس **اختیاری** است و فقط درایورهایی که قابلیت
 * بررسی وضعیت تحویل را دارند، آن را پیاده‌سازی می‌کنند.
 *
 * SmsManager در متد checkStatus() بررسی می‌کند:
 *   if ($driver instanceof DeliveryReportFetcher) { ... }
 *
 * بنابراین درایورهایی که این اینترفیس را پیاده‌سازی نکنند،
 * به سادگی از بررسی وضعیت تحویل صرف‌نظر می‌شوند.
 *
 * نمونه پیاده‌سازی:
 * ```php
 * class KavenegarDriver implements SmsDriver, DeliveryReportFetcher
 * {
 *     public function send(string $phone, string $message): void { ... }
 *
 *     public function fetchDeliveryReport(string $providerMessageId): array
 *     {
 *         // Call Kavenegar status API...
 *         return [
 *             'status'     => 'delivered',  // delivered, failed, pending, unknown
 *             'delivered_at' => '2024-01-15 10:30:00',
 *         ];
 *     }
 * }
 * ```
 */
interface DeliveryReportFetcher
{
    /**
     * دریافت وضعیت تحویل یک پیامک از سرویس‌دهنده.
     *
     * @param string $providerMessageId شناسه‌ی پیامک که توسط سرویس‌دهنده برگردانده شده
     *
     * @return array{
     *     status: string,
     *     delivered_at?: string|null,
     * } آرایه‌ای شامل حداقل کلید 'status'
     *
     * @throws \Karnoweb\SmsSender\Exceptions\DriverConnectionException در صورت خطای ارتباطی
     */
    public function fetchDeliveryReport(string $providerMessageId): array;
}
```

---

## ۳. `src/Contracts/SmsUsageHandler.php`

```php
<?php

namespace Karnoweb\SmsSender\Contracts;

/**
 * قرارداد کنترل مصرف و دسترسی درایورهای SMS.
 *
 * این اینترفیس مسئول بررسی‌هایی است که **قبل از ارسال** باید انجام شود:
 * - آیا درایور فعال است؟
 * - آیا سهمیه‌ی روزانه/ماهانه تمام نشده؟
 * - آیا محدودیت نرخ (rate limit) رعایت شده؟
 *
 * SmsManager قبل از استفاده از هر درایور، این متد را فراخوانی می‌کند.
 * اگر درایور قابل استفاده نباشد، باید Exception پرتاب شود
 * تا Failover به درایور بعدی سوئیچ کند.
 *
 * اگر اپلیکیشن نیازی به کنترل مصرف ندارد، می‌تواند از پیاده‌سازی
 * پیش‌فرض NullUsageHandler استفاده کند که همیشه اجازه می‌دهد.
 *
 * پیاده‌سازی واقعی این اینترفیس در فاز ۶ انجام می‌شود.
 */
interface SmsUsageHandler
{
    /**
     * بررسی اینکه آیا درایور مشخص‌شده قابل استفاده هست یا خیر.
     *
     * @param string    $driverName نام درایور (کلید در config، مثلاً 'kavenegar')
     * @param SmsDriver $driver     نمونه‌ی ساخته‌شده‌ی درایور
     *
     * @throws \Karnoweb\SmsSender\Exceptions\DriverNotAvailableException اگر درایور قابل استفاده نباشد
     */
    public function ensureUsable(string $driverName, SmsDriver $driver): void;
}
```

---

## ۴. `src/Exceptions/SmsException.php`

```php
<?php

namespace Karnoweb\SmsSender\Exceptions;

use RuntimeException;

/**
 * کلاس پایه‌ی تمام Exception های پکیج SMS.
 *
 * هدف: کاربر بتواند با یک catch تمام خطاهای مرتبط با SMS را بگیرد:
 *
 * ```php
 * try {
 *     Sms::message('سلام')->number('09120000000')->send();
 * } catch (SmsException $e) {
 *     // هر خطای مرتبط با SMS اینجا گرفته می‌شود
 *     Log::error('SMS failed: ' . $e->getMessage());
 * }
 * ```
 *
 * سلسله‌مراتب Exception ها:
 * ─────────────────────────
 * SmsException (RuntimeException)
 * ├── InvalidDriverConfigurationException  → پیکربندی نادرست
 * ├── DriverConnectionException            → خطای ارتباطی
 * └── DriverNotAvailableException          → هیچ درایوری در دسترس نیست
 */
class SmsException extends RuntimeException {}
```

---

## ۵. `src/Exceptions/InvalidDriverConfigurationException.php`

```php
<?php

namespace Karnoweb\SmsSender\Exceptions;

/**
 * خطای پیکربندی نادرست درایور.
 *
 * این Exception در شرایط زیر پرتاب می‌شود:
 * - کلاس درایور در config تعریف نشده یا وجود ندارد
 * - هیچ درایوری در config تعریف نشده
 * - گیرنده‌ای مشخص نشده (No recipients)
 * - پیام یا قالبی مشخص نشده (No message/template)
 *
 * این یک خطای **قابل پیش‌بینی** است و باعث فعال‌شدن Failover می‌شود.
 * یعنی اگر درایور A کانفیگ نادرست داشته باشد، سیستم درایور B را امتحان می‌کند.
 *
 * نمونه:
 * ```php
 * throw new InvalidDriverConfigurationException(
 *     "Driver class for 'kavenegar' is not defined in config."
 * );
 * ```
 */
class InvalidDriverConfigurationException extends SmsException {}
```

---

## ۶. `src/Exceptions/DriverConnectionException.php`

```php
<?php

namespace Karnoweb\SmsSender\Exceptions;

/**
 * خطای ارتباط با سرویس‌دهنده‌ی پیامک.
 *
 * این Exception باید توسط درایورها در شرایط زیر پرتاب شود:
 * - Timeout در ارتباط با API سرویس‌دهنده
 * - خطای HTTP (5xx, 4xx)
 * - خطای DNS یا شبکه
 * - پاسخ نامعتبر از سرویس‌دهنده
 *
 * این یک خطای **قابل پیش‌بینی** است و باعث فعال‌شدن Failover می‌شود.
 *
 * نکته مهم برای توسعه‌دهندگان درایور:
 * ─────────────────────────────────────
 * حتماً Exception اصلی را به عنوان $previous پاس بدهید
 * تا زنجیره‌ی خطا برای debug قابل ردیابی باشد:
 *
 * ```php
 * try {
 *     $http->post('https://api.kavenegar.com/...');
 * } catch (HttpException $e) {
 *     throw new DriverConnectionException(
 *         message:  "Kavenegar API error: {$e->getMessage()}",
 *         code:     $e->getCode(),
 *         previous: $e,
 *     );
 * }
 * ```
 */
class DriverConnectionException extends SmsException {}
```

---

## ۷. `src/Exceptions/DriverNotAvailableException.php`

```php
<?php

namespace Karnoweb\SmsSender\Exceptions;

/**
 * خطای عدم دسترسی به هیچ درایور SMS.
 *
 * این Exception زمانی پرتاب می‌شود که:
 * - تمام درایورها (default + failover) امتحان شده‌اند و همه شکست خورده‌اند
 * - هیچ درایور usable (از نظر UsageHandler) وجود ندارد
 *
 * این آخرین Exception در زنجیره‌ی Failover است و معنایش این است:
 * "ما همه‌ی راه‌ها را امتحان کردیم و هیچ‌کدام جواب نداد."
 *
 * $previous شامل آخرین Exception درایور شکست‌خورده است
 * تا بتوان علت اصلی را ردیابی کرد.
 *
 * نمونه استفاده در SmsManager:
 * ```php
 * // بعد از امتحان همه‌ی درایورها
 * throw new DriverNotAvailableException(
 *     message:  'No SMS drivers are available to send messages.',
 *     previous: $lastException,
 * );
 * ```
 *
 * نمونه catch در اپلیکیشن:
 * ```php
 * try {
 *     Sms::message('سلام')->number('09120000000')->send();
 * } catch (DriverNotAvailableException $e) {
 *     // هیچ درایوری در دسترس نیست — اطلاع‌رسانی به ادمین
 *     Alert::critical('All SMS drivers are down!', $e);
 * }
 * ```
 */
class DriverNotAvailableException extends SmsException {}
```

---

## ۸. `tests/Unit/Contracts/SmsDriverContractTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Contracts;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Drivers\NullDriver;
use Karnoweb\SmsSender\Tests\TestCase;
use ReflectionMethod;

/**
 * تست‌های قرارداد SmsDriver.
 *
 * هدف: اطمینان از اینکه اینترفیس SmsDriver ساختار درست دارد
 * و درایور NullDriver (به عنوان نمونه‌ی مرجع) آن را رعایت می‌کند.
 */
class SmsDriverContractTest extends TestCase
{
    // ─── Interface Structure ───────────────────────────────

    public function test_sms_driver_interface_exists(): void
    {
        $this->assertTrue(
            interface_exists(SmsDriver::class),
            'SmsDriver interface must exist.',
        );
    }

    public function test_sms_driver_has_send_method(): void
    {
        // متد send باید در اینترفیس تعریف شده باشد
        $this->assertTrue(
            method_exists(SmsDriver::class, 'send'),
            'SmsDriver must declare a send() method.',
        );
    }

    public function test_send_method_signature(): void
    {
        // بررسی امضای متد: دو پارامتر string و خروجی void
        $method = new ReflectionMethod(SmsDriver::class, 'send');
        $params = $method->getParameters();

        $this->assertCount(2, $params, 'send() must accept exactly 2 parameters.');

        // پارامتر اول: $phone
        $this->assertEquals('phone', $params[0]->getName());
        $this->assertEquals('string', $params[0]->getType()?->getName());

        // پارامتر دوم: $message
        $this->assertEquals('message', $params[1]->getName());
        $this->assertEquals('string', $params[1]->getType()?->getName());

        // خروجی: void
        $this->assertEquals('void', $method->getReturnType()?->getName());
    }

    // ─── NullDriver as Reference Implementation ────────────

    public function test_null_driver_implements_sms_driver(): void
    {
        $driver = new NullDriver();

        $this->assertInstanceOf(SmsDriver::class, $driver);
    }

    public function test_null_driver_does_not_implement_delivery_report(): void
    {
        // NullDriver نباید DeliveryReportFetcher را پیاده‌سازی کند
        // چون قابلیت بررسی وضعیت ندارد
        $driver = new NullDriver();

        $this->assertNotInstanceOf(DeliveryReportFetcher::class, $driver);
    }

    public function test_null_driver_send_does_not_throw(): void
    {
        // NullDriver باید بدون خطا اجرا شود (Null Object Pattern)
        $driver = new NullDriver();

        // اگر Exception پرتاب شود، تست fail می‌شود
        $driver->send('09120000000', 'Test message');

        $this->assertTrue(true); // رسیدن به اینجا یعنی موفقیت
    }

    public function test_null_driver_accepts_config(): void
    {
        // درایور باید config را بپذیرد حتی اگر استفاده نکند
        $config = ['api_key' => 'test_key'];
        $driver = new NullDriver($config);

        $this->assertInstanceOf(SmsDriver::class, $driver);
    }
}
```

---

## ۹. `tests/Unit/Contracts/DeliveryReportFetcherContractTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Contracts;

use Karnoweb\SmsSender\Contracts\DeliveryReportFetcher;
use Karnoweb\SmsSender\Tests\TestCase;
use ReflectionMethod;

/**
 * تست‌های قرارداد DeliveryReportFetcher.
 *
 * هدف: اطمینان از ساختار صحیح اینترفیس اختیاری Delivery Report.
 */
class DeliveryReportFetcherContractTest extends TestCase
{
    public function test_interface_exists(): void
    {
        $this->assertTrue(
            interface_exists(DeliveryReportFetcher::class),
            'DeliveryReportFetcher interface must exist.',
        );
    }

    public function test_has_fetch_delivery_report_method(): void
    {
        $this->assertTrue(
            method_exists(DeliveryReportFetcher::class, 'fetchDeliveryReport'),
            'DeliveryReportFetcher must declare fetchDeliveryReport() method.',
        );
    }

    public function test_fetch_delivery_report_signature(): void
    {
        $method = new ReflectionMethod(DeliveryReportFetcher::class, 'fetchDeliveryReport');
        $params = $method->getParameters();

        // یک پارامتر: $providerMessageId
        $this->assertCount(1, $params);
        $this->assertEquals('providerMessageId', $params[0]->getName());
        $this->assertEquals('string', $params[0]->getType()?->getName());

        // خروجی: array
        $this->assertEquals('array', $method->getReturnType()?->getName());
    }

    public function test_interface_is_independent_from_sms_driver(): void
    {
        // DeliveryReportFetcher نباید از SmsDriver ارث‌بری کند
        // چون اختیاری است و درایور می‌تواند هر دو را جداگانه implement کند
        $reflection = new \ReflectionClass(DeliveryReportFetcher::class);

        $this->assertEmpty(
            $reflection->getInterfaceNames(),
            'DeliveryReportFetcher should not extend other interfaces.',
        );
    }
}
```

---

## ۱۰. `tests/Unit/Exceptions/ExceptionsTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Exceptions;

use Karnoweb\SmsSender\Exceptions\DriverConnectionException;
use Karnoweb\SmsSender\Exceptions\DriverNotAvailableException;
use Karnoweb\SmsSender\Exceptions\InvalidDriverConfigurationException;
use Karnoweb\SmsSender\Exceptions\SmsException;
use Karnoweb\SmsSender\Tests\TestCase;
use RuntimeException;

/**
 * تست‌های ساختار و سلسله‌مراتب Exception های پکیج.
 *
 * اطمینان از اینکه:
 * ۱. تمام Exception ها از SmsException ارث‌بری می‌کنند (catchability یکپارچه)
 * ۲. SmsException از RuntimeException ارث‌بری می‌کند
 * ۳. پیام و previous به درستی کار می‌کنند
 * ۴. هر Exception قابل catch با کلاس والد است
 */
class ExceptionsTest extends TestCase
{
    // ─── Hierarchy ─────────────────────────────────────────

    public function test_sms_exception_extends_runtime_exception(): void
    {
        // SmsException باید RuntimeException باشد
        // تا با استانداردهای PHP سازگار باشد
        $exception = new SmsException('test');

        $this->assertInstanceOf(RuntimeException::class, $exception);
    }

    public function test_invalid_driver_configuration_extends_sms_exception(): void
    {
        $exception = new InvalidDriverConfigurationException('test');

        $this->assertInstanceOf(SmsException::class, $exception);
        $this->assertInstanceOf(RuntimeException::class, $exception);
    }

    public function test_driver_connection_extends_sms_exception(): void
    {
        $exception = new DriverConnectionException('test');

        $this->assertInstanceOf(SmsException::class, $exception);
        $this->assertInstanceOf(RuntimeException::class, $exception);
    }

    public function test_driver_not_available_extends_sms_exception(): void
    {
        $exception = new DriverNotAvailableException('test');

        $this->assertInstanceOf(SmsException::class, $exception);
        $this->assertInstanceOf(RuntimeException::class, $exception);
    }

    // ─── Message ───────────────────────────────────────────

    public function test_exception_carries_message(): void
    {
        $message = 'Driver class for kavenegar is not defined.';
        $exception = new InvalidDriverConfigurationException($message);

        $this->assertEquals($message, $exception->getMessage());
    }

    public function test_exception_carries_code(): void
    {
        $exception = new DriverConnectionException('timeout', 504);

        $this->assertEquals(504, $exception->getCode());
    }

    // ─── Previous Exception Chain ──────────────────────────

    public function test_driver_connection_exception_chains_previous(): void
    {
        // درایورها باید Exception اصلی HTTP را به عنوان previous پاس بدهند
        $httpError  = new \Exception('cURL timeout', 28);
        $exception  = new DriverConnectionException(
            message:  'Kavenegar API failed',
            code:     28,
            previous: $httpError,
        );

        $this->assertSame($httpError, $exception->getPrevious());
        $this->assertEquals(28, $exception->getCode());
    }

    public function test_driver_not_available_chains_last_failure(): void
    {
        // DriverNotAvailableException باید آخرین خطای Failover را نگه دارد
        $connectionError = new DriverConnectionException('Provider timeout');
        $exception = new DriverNotAvailableException(
            message:  'No SMS drivers are available.',
            previous: $connectionError,
        );

        $this->assertInstanceOf(
            DriverConnectionException::class,
            $exception->getPrevious(),
        );
    }

    // ─── Catch-all with Base Class ─────────────────────────

    public function test_all_exceptions_catchable_by_sms_exception(): void
    {
        // کاربر باید بتواند با یک catch(SmsException) همه خطاها را بگیرد
        $exceptions = [
            new InvalidDriverConfigurationException('config error'),
            new DriverConnectionException('connection error'),
            new DriverNotAvailableException('no driver'),
        ];

        foreach ($exceptions as $exception) {
            $caught = false;

            try {
                throw $exception;
            } catch (SmsException) {
                $caught = true;
            }

            $this->assertTrue(
                $caught,
                sprintf('%s must be catchable by SmsException.', $exception::class),
            );
        }
    }

    // ─── Not Catchable by Wrong Type ───────────────────────

    public function test_sms_exception_not_catchable_by_logic_exception(): void
    {
        // SmsException نباید با LogicException قابل catch باشد
        // چون از RuntimeException ارث‌بری می‌کند نه LogicException
        $this->expectException(SmsException::class);

        throw new InvalidDriverConfigurationException('test');
    }
}
```

---

## ۱۱. `tests/Unit/Contracts/SmsUsageHandlerContractTest.php`

```php
<?php

namespace Karnoweb\SmsSender\Tests\Unit\Contracts;

use Karnoweb\SmsSender\Contracts\SmsDriver;
use Karnoweb\SmsSender\Contracts\SmsUsageHandler;
use Karnoweb\SmsSender\Tests\TestCase;
use ReflectionMethod;

/**
 * تست‌های قرارداد SmsUsageHandler.
 */
class SmsUsageHandlerContractTest extends TestCase
{
    public function test_interface_exists(): void
    {
        $this->assertTrue(
            interface_exists(SmsUsageHandler::class),
            'SmsUsageHandler interface must exist.',
        );
    }

    public function test_has_ensure_usable_method(): void
    {
        $this->assertTrue(
            method_exists(SmsUsageHandler::class, 'ensureUsable'),
            'SmsUsageHandler must declare ensureUsable() method.',
        );
    }

    public function test_ensure_usable_signature(): void
    {
        $method = new ReflectionMethod(SmsUsageHandler::class, 'ensureUsable');
        $params = $method->getParameters();

        // دو پارامتر: $driverName و $driver
        $this->assertCount(2, $params);

        // پارامتر اول: string $driverName
        $this->assertEquals('driverName', $params[0]->getName());
        $this->assertEquals('string', $params[0]->getType()?->getName());

        // پارامتر دوم: SmsDriver $driver
        $this->assertEquals('driver', $params[1]->getName());
        $this->assertEquals(SmsDriver::class, $params[1]->getType()?->getName());

        // خروجی: void
        $this->assertEquals('void', $method->getReturnType()?->getName());
    }
}
```

---

## ✅ چک‌لیست فاز ۲

| آیتم | وضعیت |
|---|---|
| `SmsDriver` — تکمیل با مستندات و قواعد پیاده‌سازی | ✅ |
| `DeliveryReportFetcher` — اینترفیس اختیاری با PHPDoc | ✅ |
| `SmsUsageHandler` — قرارداد کنترل مصرف (پیاده‌سازی فاز ۶) | ✅ |
| `SmsException` — کلاس پایه (RuntimeException) | ✅ |
| `InvalidDriverConfigurationException` — خطای پیکربندی | ✅ |
| `DriverConnectionException` — خطای ارتباطی | ✅ |
| `DriverNotAvailableException` — عدم دسترسی به درایور | ✅ |
| تست ساختار اینترفیس `SmsDriver` + امضای متد | ✅ |
| تست ساختار اینترفیس `DeliveryReportFetcher` | ✅ |
| تست ساختار اینترفیس `SmsUsageHandler` | ✅ |
| تست سلسله‌مراتب Exception ها | ✅ |
| تست message, code, previous chain | ✅ |
| تست catch-all با `SmsException` | ✅ |
| کامنت‌های فارسی جامع در همه فایل‌ها | ✅ |

---
